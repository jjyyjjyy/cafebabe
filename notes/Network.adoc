= Computer Network
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

== 路由

以太网交换机:

 以太网交换机工作在数据链路层, 用于在同一网络中的设备转发以太网帧.

路由器:

 负责不同网络之间的数据包传送.
 路由器通过路由表来确定用于转发数据包的最佳路径.
 当网络向不同IP网络中的设备发送数据包时, 数据包会先被转发到默认网关.

== PDU

|===
| 协议 | PDU | 英文名 | 标识

| 物理层
| 比特
| bit
|

| 链路层
| 帧
| frame
| MAC地址

| 网络层
| 数据包
| packet
| IP地址

| 传输层
| 数据段
| segment
| 端口号

| 应用层
| 报文
| message
| 应用协议

|===

== 数据链路层

=== CSMA/CD

. 一个站点首先检测网络上正在发送的信号, 并在网络空闲时发送自己的帧.
. 如果其他站点碰巧同时发送, 则为一次碰撞.
. 每个站点等待一个随即时间, 然后再次尝试发送.
. 随后如果再次碰撞, 等待的时间翻倍.
. 最终, 每个站点会得到机会发送, 或者在尝试一定次数(16)后超时.

=== Ethernet帧格式

. 前导字段(8)
. 目标MAC地(6)
. 源MAC地址(6)
. 协议类型(2)
. 上层协议数据(*46-1500字节*)
. FCS(4) 发送和接收由硬件处理

协议类型:

* IPv4: 0x0800
* IPv6: 0x86dd
* ARP: 0x0806
* RARP: 0x80

超度超过1500时为Ethernet2协议, 否则为802.3协议.

=== ARP帧格式

ARP提供网络层地址到硬件地址的映射

. 目标地址(1.1.1.1)
. 源地址
. 类型(0x0806)
. 硬件类型(Ethernet(1))
. 协议类型(IPv4)
. 硬件地址大小
. 协议地址大小
. Opcode: ARP请求(1)/应答(2)
. 发送方MAC地址
. 发送方IP地址
. 接收方MAC地址
. 接收方IP地址

== IP

IP提供了一种尽力而为,无连接的数据包交付服务.

. 版本(0x0100/0x0110)
. 首部长度(一般为0101)
. Differentiated Service
. Explicit Congestion Notification
. 总长度
. 数据报标识
. 分片标记
. 分片偏移
. 生存时间
. 传输层协议类型
. 头部校验和
. 源IP地址
. 目的IP地址
. 选项

IP数据包最大为65535字节, 当一个IP数据包大于以太网的MTU时, IP协议会把数据包报文切分为多个小的片段.

=== IPv6格式

* 长度为128位, 表现为16进制, 每16位为一块. 如 `5f05:2000:80ad:5800:58:800:2023:1d71` .
* a到f的16进制数必须小写.
* 每一块中前导0必须省略不写, 如 `2001:0db8::0022` 必须要写成 `2001:0db8::22` .
* 最长的全0块必须简写成 `::` , 如果有两个最长的全0块, 则第一个简写. 如 `5f05:0000:0000:5800:58:0000:0000:1d71` 简写成 `5f05::5800:58:0000:0000:1d71` .

=== IPv4分类

|===
| 类别 | 前导位 | 用途

| A
| 0
| 单播/特殊

| B
| 10

| C
| 110

| D
| 1110

| E
| 1111

|===

== TCP

> TCP是一种可靠地, 面向连接的, 基于字节流的, 全双工的协议.

* 面向连接的: 通信双方建立连接时要经过三次握手, 断开连接时要经过四次挥手.
* 可靠地:
** 每个TCP首部都有两字节表示校验和, 如果收到一个校验和有差错的报文, TCP会直接丢弃该报文等待重传.
** TCP的序列号保证了接收数据的顺序.
** TCP在发送数据后会启动一个定时器, 等待对方确认收到这个数据包.
如果在指定时间内没有收到ACK确认包, 就会重传数据包.
** TCP提供了拥塞控制机制.
** 面向字节的: 字节写入内核后, 最终TCP以多少条报文发送出去是不确定的.
** 全双工的: 通信的双方可以同时发送/接收数据.

=== 首部

. 源端口
. 目的端口
. 序列号: 序列号用于保证包的顺序, 或者交换彼此的报文(SYN报文).
. 确认号: TCP使用确认号来告知对方下一个期望接受的序列号.
* 确认号表示小于此确认号的字节都已经收到.
* 不是所有包都需要确认.
* 收到了数据包可以延迟一会儿再确认.
* ACK包不需要确认.
. 首部长度
. 标志位
* Nonce
* Congest Window reduced
* ECN-Echo
* Urgent
* Acknowledgement: 标识确认数据包.
* Push: 告知对方这些数据包收到后应立即交给上层应用, 不能缓存起来.
* Reset: 标识强制断开连接.
* Syn: 标识这个数据包用于发起连接时同步双方的初始序列号.
* Fin: 告知对方自己发送完了所有数据, 后续不会再有数据发送了.
. 窗口大小: 窗口大小值*缩放因子
. 校验和
. 紧急指针
. 可选项/Padding

=== MSS

TCP MSS = MTU - IP header头大小 - TCP 头大小 (stem:[1500-20-20=1460])

=== 端口号

端口号被划分成以下 3 种类型：

* 熟知端口号（0~1023)
* 已登记的端口（1024~49151）
* 临时端口号（49152~65535）`cat /proc/sys/net/ipv4/ip_local_port_range`

=== 三次握手

. [C]客户端发送SYN包. `SYN-SENT`
. [S]服务端接收到后加一作为ACK包, 然后自己生成一个SYN包一起发送. `SYN-RECV`
.. 服务端此时会将这个连接信息放入 _半连接队列_ `(SYN 队列)` .
. [C]客户端接收到服务端的SYN包加一, 作为ACK包发送给服务端. `ESTABLISHED`
.. 服务端收到客户端的ACK包后会将这个连接信息移动到 _全连接队列_ `(Accept队列)` . 此时socket处于 `ESTABLISHED` 状态,每次调用 `accept` 函数会移除队列头的连接. 如果队列为空, 则会阻塞 `accept` 函数.

=== 四次挥手

. [C]客户端发送FIN包, 以后客户端不能再发送数据给服务端了. `FIN-WAIT-1`
. [S]服务端接收到后回复ACK包. `CLOSE-WAIT`
. [C]客户端接收到ACK包. `FIN-WAIT-2`
. [S]服务端发送FIN包. `LAST-ACK`
. [C]客户端收到FIN包, 发送ACK包. `TIME-WAIT`
. [S]服务端收到ACK包断开连接. `CLOSED`
. [C]客户端经过两个MSL后断开连接. `CLOSED`

[qanda]
TIME-WAIT 状态存在的意义?::
* 保证上一个连接的包不会因为网络慢发送到一个连接里.
* 可以收到对方的第二个 `FIN` 包.
* 如果主动断开方重用端口, 进行三次握手发送SYN包, 对方( `LAST_ACK` )立即会返回 `RST` 包导致三次握手失败.
为什么是两个MSL?::
* 1个MSL保证 `ACK` 包能发送到对方.
* 1个MSL保证对方如果没有收到 `ACK` 包, 那么可以收到对方重传的 `FIN` 包.

=== TCP timestamp option header

TCP时间戳选项首部由四部分组成:

* Kind: 时间戳类别固定为8
* Length: 固定为10
* TS value
* TS echo reply

. 三次握手SYN包将时间戳写在 `TS value` 字段上.
. 服务端收到SYN包后, 将收到的 `TS value` 写到 `TS echo reply` 字段上, 然后生成自己的时间戳写到 `TS value` 字段上.
. 以此往复.

=== TCP Fast Open

=== SO_REUSEADDR

TCP四次挥手后, 主动断开连接的一方会进入 `TIME_WAIT` 状态, 等待两个MSL后才最终释放这个连接, 此时进程虽然结束, 但是不能在 `TIME_WAIT` 状态下继续使用该端口.
`SO_REUSEADDR` 设置为1后即使在 `TIME_WAIT` 状态下也可以复用该端口.

=== SO_LINGER

[source,c]
----
struct linger {
    int l_onoff;    /* linger active */
    int l_linger;   /* how many seconds to linger for */
};
----

* `l_onoff` 为0时表示禁用该特性, close函数会立即返回，操作系统负责把缓冲队列中的数据全部发送至对方.
* `l_onoff` 为非0时表示启用该特性.
** `l_linger` 为0, close函数会立即返回，不执行正常的四次挥手, 操作系统把缓冲区数据全部丢弃并立即发送RST包重置连接.
** `l_linger` 为非0, 那么此时close函数在l_linger时间内发送数据, 之后操作系统把缓冲区数据全部丢弃并立即发送RST包重置连接.

== 网络查看命令行工具

=== netstat

_netstat_ 能够查看所有已连接的TCP/UDP网络连接, 网络协议分析, 端口分析, 查看路由表等.

==== 安装

[source,bash]
----
sudo apt install net-tools
----

==== 命令选项

* `-l` 显示所有正在 `listen` 的socket
* `-a` 显示所有的socket
* `-r` 显示路由表
* `-i` 显示所有接口
* `-g` 显示所有广播组
* `-s` 显示网络使用情况
* `-M` 显示所有伪装的链接
* `-v` 显示详细信息
* `-W` 显示时不截断ip地址
* `-n` 不解析主机名
* `-e` 显示更多信息
* `-p` 显示socket的进程id
* `-o` 显示所有的定时器
* `-F` 显示转发信息
* `-C` 显示路由缓存

==== 命令示例

[source,bash]
----
# 查看端口占用的进程
sudo netstat -lnp | grep 22| awk '{print $NF}'

# 查看IPv4监听的端口列表
sudo netstat -vutlnp --listening -4

# 查看tcp使用情况分析
sudo netstat -st

# 查看所有监听的unix socket
sudo netstat -lx

----

=== ss

ss相比于netstat还能够查看更多socket信息.

==== 安装

[source,bash]
----
sudo apt install iproute2 iproute2-doc
----

==== 命令选项

* `-n` 不解析服务名称
* `-r` 解析主机
* `-l` 显示所有监听中的socket
* `-o` 显示所有的定时器
* `-e` 显示socket详细信息
* `-m` 显示socket内存使用
* `-p` 显示socket所属的进程
* `-s` 显示socket使用概况
* `-4` 仅显示 IPv4 socket
* `-6` 仅显示 IPv6 socket
* `–0` 显示 PACKET sockets
* `-t` 显示 TCP sockets
* `-S` 显示 SCTP sockets
* `-u` 显示 UDP sockets
* `-w` 显示 RAW sockets
* `-x` 显示 Unix domain sockets
* `-f` 显示指定FAMILY_TYPE的sockets, 支持 unix, inet, inet6, link, netlink
* `-tun` 不解析主机名

==== 命令示例

[source,bash]
----
# 查看指定目标地址/端口的连接
ss dst 192.168.0.2

# 查看指定状态的socket
ss state ESTABLISHED

# 查看port小于1024的socket
ss -n sport \< 1024

----

== Appendix

. 路由器的主要功能和特性是什么？
. 在小型路由网络中，如何将设备连接起来？
. 如何使用CLI配置路由器上的基本设置，以实现两个直连网络之间的路由？
. 如何检验直连到路由器的两个网络之间的连接？
. 在接口之间交换数据包时，路由器使用的封装和解封装的过程是什么？
. 什么是路由器的路径决定功能？
. 直连网络的路由表条目是什么？
. 路由器如何创建直连网络的路由表？
. 路由器如何使用静态路由创建路由表？
. 路由器如何使用动态路由协议创建路由表？
