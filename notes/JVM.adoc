= JVM
:doctype: book
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:sectlinks:
:toc: left
:toc-title: 目录

== JDK常用工具

* jps

 查看系统运行的所有Java进程的pid

* jinfo [option] <pid>

 查看指定Java进程信息. 如: jinfo -flags 1 查看pid为1的进程的所有启动参数. jinfo -flag <FLAG_NAME> 1 查看1进程指定flag的值

* jstack <pid>

 查看指定Java进程中每个线程栈信息

* jstat [option] <pid> [interval]

 查看指定进程的内存概况. 如: jstat -gcutil 1 1000 每隔1秒输出1进程的概况

== JVM参数概述

JVM主要接受两类标志: boolean类和赋值类参数.

* boolean类:
 `-XX:+FLAG_NAME`. 如: `-XX:+UseCompressedOops` 开启64位JVM中的对象引用压缩,`-XX:-UseCompressedOops` 关闭压缩.

* 赋值类: `-XX:+FLAG_NAME=VALUE`. 如 `-XX:AutoBoxCacheMax=20000`.

查看所有可选标志: `java -XX:+PrintFlagsFinal -version`

== 常用启动参数

-XX:+PrintGCDetails

 开启gc日志

-Xloggc:FILENAME

 gc日志写入指定文件

-XX:+UseGCLogfileRotation

 启用gc日志文件切割

-XX:NumberOfGCLogfiles=N

-XX:GCLogfileSize=N

== 垃圾收集器(Garbage Collector)

[.lead]
垃圾收集分两步: 查找不再使用的对象, 然后释放这些对象所在的内存.

[%hardbreaks]
[.lead]
由于对象的生存时间不同, 所有的垃圾收集器都采用分代收集的方式.
堆内存被划分为 *新生代* (Young Generation)和 *老年代* (Old Generation或Tenured Generation),新生代又被分为一个Eden区和两个Survivor区.
对象首先在新生代Eden区分配, Eden区填满时, 垃圾收集器会暂停所有应用线程回收新生代(垃圾收集时所有应用线程停止运行所产生的停顿称为 **STW**(stop-the-world)).此时不再使用的对象会被回收, 仍在使用的对象会移动到Survivor区或老年代. 这一过程称为 *Minor GC*. 由于所有的存活对象都被移走, 此时相当于在新生代做了一次整理.
对象不断移动到老年代, 等到老年代空间占满, JVM会回收老年代内存. 这一过程称为 *FULL GC*.
所有的垃圾收集器在Minor GC时都会产生STW. 但FULL GC时不一定会产生STW,

* Serial垃圾收集器

[.lead]
Serial垃圾收集器使用单线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseSerialGC` 启用Serial垃圾收集器.

* Parallel垃圾收集器

TIP: JDK8默认收集器

[.lead]
Parallel垃圾收集器使用多线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseParallelGC` 启用Parallel垃圾收集器.

* CMS收集器

[.lead]
CMS回收新生代时会暂停所有应用线程, 使用多线程回收. 在FULL GC时不再暂停应用线程, 而是使用若干个后台线程定期扫描老年代, 及时回收不再使用的对象.
但是当堆变得碎片化, CMS会退化成Serial收集器使用单线程回收内存并整理老年代, 之后再恢复成多线程收集.
使用 `-XX:+UseConcMarkSweepGC -XX:+UseParNewGC` 启用CMS收集器.

* G1收集器

TIP: JDK9默认收集器

使用 `-XX:+UseG1GC` 启动G1收集器

* ZGC收集器

WARNING: JDK11新增收集器

使用 `-XX:+UseZGC` 启动ZGC收集器

== GC调优

* 永远不要把堆内存的大小设置的比机器物理内存大.

 FULL GC时JVM会访问整个堆的内容, 内存交换会拖慢GC的速度. 使用-Xms和-Xmx分别设置堆内存的最小值和最大值.
 默认64位JVM堆内存初始值为取512MB和物理内存大小1/64二者中的最小值, 最大值取32G和物理内存大小1/4二者中的最小值.

* 调整新生代与老年代的大小

.新生代大小设置参数, 后者优先级更高
** -XX:NewRatio 设置新生代与老年代的比例, 默认值为2. 默认情况下新生代大小初始值等于 `初始堆大小/(1+NewRatio)`
** -XX:NewSize 设置新生代大小的初始值
** -XX:MaxNewSize 设置新生代大小的最大值
** -Xmn 同时设置新生代的初始值和最大值

推荐设置: `-XX:NewRatio=4`

* 选择恰当的垃圾收集器

