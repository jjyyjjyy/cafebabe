= JVM
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

== JVM概述

JVM是一个支持在不同操作系统上执行Java字节码的运行时容器, 拥有内存管理/垃圾回收等功能.
Java字节码无法直接执行, JVM需要将其翻译成机器码.
在HotSpot里, 该翻译过程有两种形式:

* 解释执行: 逐条将字节码翻译成机器码.
* 即时编译执行: 将一个方法中所有的字节码翻译成机器码后再执行.

HotSpot内置多种编译器: C1(启动块,编译时间短)/C2(编译时间比较长,但执行效率高)

== JVM数据类型

|===
| 类型 | 值域 | 默认值 | 标记

| boolean
| {false,true}
| false
| Z

| byte
| [-128,127]
| 0
| B

| short
| [stem:[-2^15,2^15-1]]
| 0
| S

| int
| [stem:[-2^31,2^31-1]]
| 0
| I

| long
| [stem:[-2^63,2^63-1]]
| 0
| J

| char
| [stem:[0,2^16-1]]
| '\u0000'
| C

| float
| [stem:[-3.4E38,3.4E38]]
| +0.0F
| F

| double
| [stem:[-1.8E308,1.8E308]]
| +0.0D
| D

|===

== Class文件组成

* magic number
* minor&major versions
* constant pool
* access flags
* this class
* super class
* interfaces
* fields
* methods
* attributes

== JDK常用工具

* jps

 查看系统运行的所有Java进程的pid

* jinfo [option] <pid>

 查看指定Java进程信息. 如: jinfo -flags 1 查看pid为1的进程的所有启动参数. jinfo -flag <FLAG_NAME> 1 查看1进程指定flag的值

* jstack <pid>

 查看指定Java进程中每个线程栈信息

* jstat [option] <pid> [interval]

 查看指定进程的内存概况. 如: jstat -gcutil 1 1000 每隔1秒输出1进程的概况

* javap <class file>
** -c: 反编译class
** -p: 显示 `private` 方法和字段
** -v: 显示详细信息
** -s: 显示类型签名
** -l: 输出行号和本地变量表
** -sysinfo: 显示类的系统信息

== JVM参数概述

JVM主要接受两类标志: boolean类和赋值类参数.

* boolean类:
 `-XX:+FLAG_NAME`.
如: `-XX:+UseCompressedOops` 开启64位JVM中的对象引用压缩,`-XX:-UseCompressedOops` 关闭压缩.

* 赋值类: `-XX:+FLAG_NAME=VALUE`.
如 `-XX:AutoBoxCacheMax=20000`.

查看所有可选标志: `java -XX:+PrintFlagsFinal -version`

== 常用启动参数

-XX:+PrintGCDetails

 开启gc日志

-Xloggc:FILENAME

 gc日志写入指定文件

-XX:+UseGCLogfileRotation

 启用gc日志文件切割

-XX:NumberOfGCLogfiles=N

-XX:GCLogfileSize=N

== 查看JVM CPU占用高的原因方法:

. `jps` 查看JVM进程 `PID`.
. `top -Hp PID` 查看该JVM进程内线程资源占用情况.找到占用资源高的线程 `TID`.
. `printf '%x\n' TID` 将线程id转成16进制数.
. `jstack PID | grep TID -A 10` 查看该线程所在堆栈, 检查堆栈所在代码上的错误.

== 垃圾收集器(Garbage Collector)

[.lead]
垃圾收集分两步: 查找不再使用的对象, 然后释放这些对象所在的内存.

[%hardbreaks]
[.lead]
由于对象的生存时间不同, 所有的垃圾收集器都采用分代收集的方式.
堆内存被划分为 *新生代* (Young Generation)和 *老年代* (Old Generation或Tenured Generation),新生代又被分为一个Eden区和两个Survivor区.
对象首先在新生代Eden区分配, *Eden区填满时*, 垃圾收集器会暂停所有应用线程回收新生代(垃圾收集时所有应用线程停止运行所产生的停顿称为 **STW**(stop-the-world)).此时不再使用的对象会被回收, 仍在使用的对象会移动到Survivor区或老年代. 这一过程称为 *Minor GC*. 由于所有的存活对象都被移走, 此时相当于在新生代做了一次整理.
对象不断移动到老年代, 等到 *老年代空间占满*, JVM会回收整个堆. 这一过程称为 *Full GC*.
所有的垃圾收集器在Minor GC时都会产生STW. 但FULL GC时不一定会产生STW,

* Serial垃圾收集器

[.lead]
Serial垃圾收集器使用单线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseSerialGC` 启用Serial垃圾收集器.

* Parallel垃圾收集器

TIP: JDK8默认收集器

[.lead]
Parallel垃圾收集器使用多线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseParallelGC` 启用Parallel垃圾收集器.

* CMS收集器

[.lead]
CMS回收新生代时会暂停所有应用线程, 使用多线程回收.
在Full GC时不再暂停应用线程, 而是使用若干个后台线程定期扫描老年代, 及时回收不再使用的对象.
但是当堆变得碎片化, CMS会退化成Serial收集器使用单线程回收内存并整理老年代, 之后再恢复成多线程收集.
使用 `-XX:+UseConcMarkSweepGC` 启用CMS收集器.

* G1收集器

TIP: JDK9默认收集器

使用 `-XX:+UseG1GC` 启动G1收集器

* ZGC收集器

WARNING: JDK11新增收集器

使用 `-XX:+UseZGC` 启动ZGC收集器

== GC调优

* 永远不要把堆内存的大小设置的比机器物理内存大.

 Full GC时JVM会访问整个堆的内容, 内存交换会拖慢GC的速度. 使用-Xms和-Xmx分别设置堆内存的最小值和最大值.
 默认64位JVM堆内存初始值为取512MB和物理内存大小1/64二者中的最小值, 最大值取32G和物理内存大小1/4二者中的最小值.

* 调整新生代与老年代的大小

.新生代大小设置参数, 后者优先级更高
** -XX:NewRatio 设置新生代与老年代的比例, 默认值为2. 默认情况下新生代大小初始值等于 `初始堆大小/(1+NewRatio)`
** -XX:NewSize 设置新生代大小的初始值
** -XX:MaxNewSize 设置新生代大小的最大值
** -Xmn 同时设置新生代的初始值和最大值

推荐设置: `-XX:NewRatio=4`

* 选择恰当的垃圾收集器

== gc日志分析

=== Parallel垃圾收集器

==== Parallel Minor GC

[source,txt]
----
{Heap before GC invocations=5 (full 2):
 PSYoungGen      total 1450496K, used 1284666K [0x0000000595580000, 0x0000000621980000, 0x00000007c0000000)
  eden space 1424384K, 90% used [0x0000000595580000,0x00000005e3c0e8b8,0x00000005ec480000)
  from space 26112K, 0% used [0x0000000620000000,0x0000000620000000,0x0000000621980000)
  to   space 174592K, 0% used [0x000000060c480000,0x000000060c480000,0x0000000616f00000)
 ParOldGen       total 2796544K, used 30083K [0x0000000140000000, 0x00000001eab00000, 0x0000000595580000)
  object space 2796544K, 1% used [0x0000000140000000,0x0000000141d60f58,0x00000001eab00000)
 Metaspace       used 56984K, capacity 58972K, committed 59136K, reserved 1099776K
  class space    used 7427K, capacity 7846K, committed 7936K, reserved 1048576K
2018-07-25T10:15:43.831+0000: 7.861: [GC (Metadata GC Threshold)
Desired survivor size 178782208 bytes, new threshold 7 (max 15)
[PSYoungGen: 1284666K->30929K(1958400K)] // <1>
 1314750K->61020K(4754944K), // <2>
  0.0605807 secs] [Times: user=0.31 sys=0.02, real=0.06 secs] // <3>
Heap after GC invocations=5 (full 2):
 PSYoungGen      total 1958400K, used 30929K [0x0000000595580000, 0x0000000620480000, 0x00000007c0000000)
  eden space 1927168K, 0% used [0x0000000595580000,0x0000000595580000,0x000000060af80000)
  from space 31232K, 99% used [0x000000060c480000,0x000000060e2b4420,0x000000060e300000)
  to   space 174592K, 0% used [0x0000000615a00000,0x0000000615a00000,0x0000000620480000)
 ParOldGen       total 2796544K, used 30091K [0x0000000140000000, 0x00000001eab00000, 0x0000000595580000)
  object space 2796544K, 1% used [0x0000000140000000,0x0000000141d62f58,0x00000001eab00000)
 Metaspace       used 56984K, capacity 58972K, committed 59136K, reserved 1099776K
  class space    used 7427K, capacity 7846K, committed 7936K, reserved 1048576K
}
----
<1> 新生代的空间使用从1284MB降到30MB, 此时整个新生代大小为1958MB
<2> 整个堆的空间使用从1314MB降到61MB
<3> 本次gc花费0.06秒(并行回收)

==== Parallel Full GC

[source,txt]
----
{Heap before GC invocations=4 (full 2):
 PSYoungGen      total 1450496K, used 25798K [0x0000000595580000, 0x0000000621980000, 0x00000007c0000000)
  eden space 1424384K, 0% used [0x0000000595580000,0x0000000595580000,0x00000005ec480000)
  from space 26112K, 98% used [0x0000000620000000,0x0000000621931828,0x0000000621980000)
  to   space 174592K, 0% used [0x000000060c480000,0x000000060c480000,0x0000000616f00000)
 ParOldGen       total 2796544K, used 12907K [0x0000000140000000, 0x00000001eab00000, 0x0000000595580000)
  object space 2796544K, 0% used [0x0000000140000000,0x0000000140c9afb8,0x00000001eab00000)
 Metaspace       used 33973K, capacity 35428K, committed 35496K, reserved 1081344K
  class space    used 4333K, capacity 4600K, committed 4608K, reserved 1048576K
2018-07-25T10:15:39.817+0000: 3.847: [Full GC (Metadata GC Threshold)
[PSYoungGen: 25798K->0K(1450496K)] // <1>
[ParOldGen: 12907K->30083K(2796544K)] // <2>
38705K->30083K(4247040K), // <3>
[Metaspace: 33973K->33973K(1081344K)], 0.0771380 secs]
[Times: user=0.40 sys=0.01, real=0.07 secs]
Heap after GC invocations=4 (full 2):
 PSYoungGen      total 1450496K, used 0K [0x0000000595580000, 0x0000000621980000, 0x00000007c0000000)
  eden space 1424384K, 0% used [0x0000000595580000,0x0000000595580000,0x00000005ec480000)
  from space 26112K, 0% used [0x0000000620000000,0x0000000620000000,0x0000000621980000)
  to   space 174592K, 0% used [0x000000060c480000,0x000000060c480000,0x0000000616f00000)
 ParOldGen       total 2796544K, used 30083K [0x0000000140000000, 0x00000001eab00000, 0x0000000595580000)
  object space 2796544K, 1% used [0x0000000140000000,0x0000000141d60f58,0x00000001eab00000)
 Metaspace       used 33973K, capacity 35428K, committed 35496K, reserved 1081344K
  class space    used 4333K, capacity 4600K, committed 4608K, reserved 1048576K
}
----
<1> 新生代的占用空间从25MB降到0, 此时整个新生代大小为1450MB
<2> 老年代的占用空间从12MB升到30MB, 此时整个老年代大小为2796MB (此时老年代经过了压缩整理)
<3> 整个堆的空间占用从38MB降到30MB, 此时整个堆的大小为4247MB

=== CMS垃圾收集器

=== Interview

* 创建对象方式:
** new
** Object.clone()
** Class#newInstance()
** 反序列化
** Unsafe.allocateInstance
