= JVM
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

.Resources
* https://book.douban.com/subject/34907497[, window="blank"]
* https://book.douban.com/subject/26740520[, window="blank"]

== JVM概述

JVM是一个支持在不同操作系统上执行Java字节码的运行时容器, 拥有内存管理/垃圾回收等功能.
Java字节码无法直接执行, JVM需要将其翻译成机器码.
在HotSpot里, 该翻译过程有两种形式:

* 解释执行: 逐条将字节码翻译成机器码.
* 即时编译执行: 将一个方法中所有的字节码翻译成机器码后再执行.

HotSpot内置多种编译器:

* `C1` 启动块,编译时间短
* `C2` 编译时间比较长,但执行效率高
* `graal`

== JVM数据类型

|===
| 类型 | 值域 | 默认值 | 标记

| boolean
| {false,true}
| false
| Z

| byte
| [-128,127]
| 0
| B

| short
| [stem:[-2^15,2^15-1]]
| 0
| S

| int
| [stem:[-2^31,2^31-1]]
| 0
| I

| long
| [stem:[-2^63,2^63-1]]
| 0
| J

| char
| [stem:[0,2^16-1]]
| '\u0000'
| C

| float
| [stem:[-3.4E38,3.4E38]]
| +0.0F
| F

| double
| [stem:[-1.8E308,1.8E308]]
| +0.0D
| D

|===

== Class文件组成

* magic number
* minor&major versions
* constant pool
* access flags
* this class
* super class
* interfaces
* fields
* methods
* attributes

== JDK常用工具

=== jcmd

打印Java进程所涉及的基本类, 线程和VM信息

`jcmd <pid> <command> [args]`

* `jcmd 9914 VM.system_properties` 查看JVM进程properties
* `jcmd 9914 VM.uptime` 查看JVM进程运行时间
* `jcmd 9914 VM.version` 查看JVM版本
* `jcmd 9914 VM.command_line` 查看JVM启动命令
* `jcmd 9914 VM.flags` 查看JVM启动参数
* `jcmd 9914 Thread.print` 查看JVM线程栈信息

=== jps

查看系统运行的所有Java进程的pid

`jps -l`

=== jinfo

查看指定Java进程信息

`jinfo [option] <pid>`

* `jinfo -flags 1` 查看pid为1的进程的所有启动参数
* `jinfo -flag UseCompressedOops 9914` 查看指定参数

=== jstack

查看指定Java进程中每个线程栈信息

`jstack <pid>`

=== jstat

查看指定进程的内存概况. 如: jstat -gcutil 1 1000 每隔1秒输出1进程的概况

`jstat [option] <pid> [interval]`

.各列含义
* `S0` 第一个survivor区容量
* `S1` 第二个survivor区容量
* `E` Eden区容量
* `O` Old区容量
* `M` Metaspace区容量
* `YGC` young gc次数
* `YGCT` young gc总耗时
* `FGC` full gc次数
* `FGCT` full gc总耗时
* `GCT` gc总耗时

=== javap

查看class字节码文件

`javap <class file>`

* -c: 反编译class
* -p: 显示 `private` 方法和字段
* -v: 显示详细信息
* -s: 显示类型签名
* -l: 输出行号和本地变量表
* -sysinfo: 显示类的系统信息

== JVM参数

=== 参数分类

JVM主要接受两类标志: boolean类和赋值类参数.

* boolean类:
 `-XX:+FLAG_NAME`.
如: `-XX:+UseCompressedOops` 开启64位JVM中的对象引用压缩,`-XX:-UseCompressedOops` 关闭压缩.

* 赋值类: `-XX:+FLAG_NAME=VALUE`.
如 `-XX:AutoBoxCacheMax=20000`.

* 简写类.
如 `-Xms -Xmx -Xmn -Xss`

TIP: 查看所有可选标志: `java -XX:+PrintFlagsFinal -version`

=== 常用启动参数

==== GC收集器选择类

* `-XX:+UseSerialGC` 使用Serial+Serial Old组合回收新生代和老年代.
* `-XX:+UseParNewGC` 使用ParNew+Serial Old组合回收新生代和老年代.
* `-XX:+UseConcMarkSweepGC` 使用ParNew+CMS组合回收新生代和老年代, 当出现 _Concurrent Mode Failure_ 后使用Serial Old回收老年代.
* `-XX:+UseParallelGC` 使用Parallel Scavenge+Serial Old组合回收新生代和老年代.
* `-XX:+UseParallelOldGC` 使用Parallel Scavenge+Parallel Old组合回收新生代和老年代.
* `-XX:+UseG1GC` 使用G1回收堆内存.
* `-XX:+UseZGC` 使用ZGC回收堆内存.
* `-XX:+UseShenandoahGC` 使用ShenandoahGC回收堆内存, 只能在OpenJDK12及以上版本中使用.

==== Java8及以下GC日志输出类

* `-XX:+PrintGC` 输出GC简要日志.
* `-XX:+PrintGCDetails` 输出gc详细日志.
* `-XX:+PrintHeapAtGC` 输出GC前后堆和方法区容量大小.
* `-XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime` 输出GC与用户线程并发时间以及GC停顿时间.
* `-XX:+PrintAdaptiveSizePolicy` 查看JVM堆各个分代大小自动调节信息.
* `-XX:+PrintTenuringDistribution` 查看GC后剩余对象的年龄分布信息.
* `-Xloggc:<FILENAME> -XX:+UseGCLogfileRotation -XX:NumberOfGCLogfiles=N -XX:GCLogfileSize=N` gc日志写入指定文件并切割.

==== Java9及以下GC日志输出类

`-Xlog[:[selector][:[output][:[decorators][:output-options]]]]`

* `-Xlog:gc` 输出GC简要日志.
* `-Xlog:gc*` 输出GC详细日志.
* `-Xlog:gc+heap=debug` 输出GC前后堆和方法区容量大小.
* `-Xlog:safepoint` 输出GC与用户线程并发时间以及GC停顿时间.
* `-Xlog:gc+ergo*=trace` 查看JVM堆各个分代大小自动调节信息.
* `-Xlog:gc+age=trace` 查看GC后剩余对象的年龄分布信息.
* `-Xlog:gc*:file=<file>::filecount=<count>,filesize=<sizekb>` gc日志写入指定文件并切割.

==== GC性能类

* `-XX:SurvivorRatio=8` 新生代中 _Eden_ 区和 _Survivor_ 区的比例, 默认为8, 及 8:1:1 .
* `-XX:PretenureSizeThreshold=0` 直接晋升到老年代的对象大小, 大于这个参数的对象将直接在老年代上分配.
* `-XX:MaxTenuringThreshold=15` 晋升到老年代的对象年龄.
每个对象在 _Minor GC_ 后年龄加一, 当年龄超过这个参数后会进入老年代.
* `-XX:+UseAdaptiveSizePolicy` 动态调整堆中各个区域的大小以及老年代的年龄.
* `-XX:ParallelGCThreads=8` 设置并行GC时进行内存回收的线程数.
* `-XX:GCTimeRatio=N` 设置应用运行时间占比: stem:["Throughput"="GCTimeRatio"/(1+"GCTimeRatio")]
* `-XX:MaxGCPauseMillis=N` 设定应用可承受的最大停顿时间.一般设置为200, 如果设置的值过小, 会导致老年代非常小, 从而频繁进行 _Full GC_ .
* `-XX:CMSInitiatingOccupancyFraction=68` 设置CMS收集器在老年代空间被使用多少后触发垃圾回收, 默认为68%.
* `-XX:+UseCMSCompactAtFullCollection` 设置CMS在 _Full GC_ 后是否进行内存碎片整理. [Java9后废弃]
* `-XX:CMSFullGCsBeforeCompaction=0` 设置CMS在多少次 _Full GC_ 后进行内存碎片整理. [Java9后废弃]
* `-XX:G1HeapRegionSize=0` 设置G1 Region大小.
* `-XX:G1NewSizePercent=5` 设置G1新生代最小值, 默认为5%.
* `-XX:G1MaxNewSizePercent=60` 设置G1新生代最大值, 默认为60%.
* `-XX:InitiatingHeapOccupancyPercent` 设置触发标记周期的堆(old+humongous)占用阈值, 默认为45%.

== 内存分配策略

=== 对象优先在Eden区分配

大多数情况下, 对象在新生代Eden区中分配.
当Eden区没有足够空间进行分配时, 虚拟机将发起一次 _Minor GC_ .

=== 大对象直接进入老年代

需要大量连续内存空间的Java对象(如数组), 直接在老年代分配.
虚拟机提供了 `-XX:PretenureSizeThreshold` 参数指定大于该参数值的对象直接在老年代分配.

=== 长期存活的对象进入老年代

对象如果在 _Minor GC_ 后仍然存活, 并能被Survivor区容纳, 则移动到Survivor区, 年龄加1. 年龄超过 `MaxTenuringThreshold` 参数后, 下次 _Minor GC_ 时会进入老年代.

=== 老年代空间分配担保

_Minor GC_ 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于等于新生代所有对象总空间或者大于等于历史晋升的平均大小, 如果大于则进行 _Minor GC_ , 否则将直接进行 _Full FC_ .

== 垃圾收集算法

=== 复制

将内存按容量划分为大小相等的两块, 每次只用其中的一块.
当某一块的内存用完了, 就将还存活的的对象复制到另外一块上, 然后再把已使用过的内存空间一次清理掉.

==== 优点

* 为对象分配内存时不需要考虑内存碎片的问题.

==== 缺点

* 可用内存只有一半.
* 如果对象的存活率高, 则拷贝对象的操作开销比较大.

==== 使用场景

* Serial/ParNew收集器使用复制算法收集新生代.

=== 标记整理

让所有存活的对象向内存空间一端移动, 然后直接清理掉边界以外的内存.

==== 优点

* 没有内存碎片

==== 缺点

* 移动对象的开销大.

==== 使用场景

* Serial Old/Parallel Scavenge使用标记-整理算法收集老年代.

=== 标记清除

首先标记出所有需要回收的对象, 在标记完成后统一回收所有被标记的对象.

==== 优点

* 相对于复制算法节省了内存空间.

==== 缺点

* 执行效率不稳定, 如果内存中大量对象需要被回收, 则必须进行大量标记和清除的动作.
* 导致内存碎片化.

==== 使用场景

* CMS使用标记清除算法回收老年代.

== 垃圾收集器

[.lead]
垃圾收集分两步: 在为对象分配内存时遇到内存不足, 查找不再使用的对象, 然后释放这些对象所在的内存.

由于对象的生存时间不同, 所有的垃圾收集器都采用分代收集的方式.
堆内存被划分为 *新生代* (Young Generation)和 *老年代* (Old Generation或Tenured Generation), 默认空间占比 1:2. 新生代又被分为一个Eden区和两个Survivor区.
默认空间占比 8:1:1.

对象首先在新生代Eden区分配, *Eden区填满时*, 垃圾收集器会暂停所有应用线程回收新生代(垃圾收集时所有应用线程停止运行所产生的停顿称为 **STW**(stop-the-world)).此时不再使用的对象会被回收, 仍在使用的对象会移动到Survivor区或老年代.
这一过程称为 *Minor GC*.
由于所有的存活对象都被移走, 此时相当于在新生代做了一次整理.
单独回收老年代的过程称为 *Major GC*.
(CMS) 回收新生代和一部分老年代的过程称为 *Mixed GC*.(G1) 对象不断移动到老年代, 等到 *老年代空间占满*, JVM会回收整个堆.
这一过程称为 *Full GC*.

=== Serial

[.lead]
Serial垃圾收集器使用单线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseSerialGC` 启用Serial垃圾收集器.

=== Parallel

TIP: JDK8默认收集器

[.lead]
Parallel垃圾收集器使用多线程回收内存, 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseParallelGC` 启用Parallel垃圾收集器.

=== CMS

[.lead]
CMS回收新生代时会暂停所有应用线程, 使用多线程回收.
在Full GC时不再暂停应用线程, 而是使用若干个后台线程定期扫描老年代, 及时回收不再使用的对象.
但是当堆变得碎片化, CMS会退化成Serial收集器使用单线程回收内存并整理老年代, 之后再恢复成多线程收集.
使用 `-XX:+UseConcMarkSweepGC` 启用CMS收集器.

=== G1

TIP: JDK9默认收集器

使用 `-XX:+UseG1GC` 启动G1收集器

=== ZGC

使用 `-XX:+UseZGC` 启动ZGC收集器

== GC调优

=== 选择恰当的垃圾收集器

* 数据分析/科学计算类应用, 关注吞吐量.
* 事务型应用, 关注低延迟.
* 客户端/嵌入式设备应用, 关注内存占用.

=== 永远不要把堆内存的大小设置的比机器物理内存大

 Full GC时JVM会访问整个堆的内容, 内存交换会拖慢GC的速度. 使用-Xms和-Xmx分别设置堆内存的最小值和最大值.
 默认64位JVM堆内存初始值为取512MB和物理内存大小1/64二者中的最小值, 最大值取32G和物理内存大小1/4二者中的最小值.

=== 调整新生代与老年代的大小

.新生代大小设置参数, 后者优先级更高
** -XX:NewRatio 设置新生代与老年代的比例, 默认值为2. 默认情况下新生代大小初始值等于 `初始堆大小/(1+NewRatio)`
** -XX:NewSize 设置新生代大小的初始值
** -XX:MaxNewSize 设置新生代大小的最大值
** -Xmn 同时设置新生代的初始值和最大值

推荐设置: `-XX:NewRatio=4`

== gc日志分析

=== Parallel垃圾收集器

==== Parallel Minor GC

[source,txt]
----
2018-07-25T10:15:43.831+0000: 7.861: [GC (Metadata GC Threshold)
Desired survivor size 178782208 bytes, new threshold 7 (max 15)
[PSYoungGen: 1284666K->30929K(1958400K)] <1>
 1314750K->61020K(4754944K), <2>
  0.0605807 secs] [Times: user=0.31 sys=0.02, real=0.06 secs] <3>
----
<1> 新生代的空间使用从1284MB降到30MB, 此时整个新生代大小为1958MB.
<2> 整个堆的空间使用从1314MB降到61MB.
<3> 本次gc花费0.06秒(并行回收), 总共消耗CPU的时间为0.31秒.

==== Parallel Full GC

[source,txt]
----
2018-07-25T10:15:39.817+0000: 3.847: [Full GC (Metadata GC Threshold)
[PSYoungGen: 25798K->0K(1450496K)] <1>
[ParOldGen: 12907K->30083K(2796544K)] <2>
38705K->30083K(4247040K), <3>
[Metaspace: 33973K->33973K(1081344K)], 0.0771380 secs] <4>
[Times: user=0.40 sys=0.01, real=0.07 secs] <5>
----
<1> 新生代的占用空间从25MB降到0, 此时整个新生代大小为1450MB.
<2> 老年代的占用空间从12MB升到30MB, 此时整个老年代大小为2796MB (此时老年代经过了压缩整理).
<3> 整个堆的空间占用从38MB降到30MB, 此时整个堆的大小为4247MB.
<4> Metaspace没有回收.
<5> 本次回收用时.0.7秒, 总消耗CPU时间0.4秒.

=== CMS垃圾收集器

[source,java]
----
// -Xmx20M -Xms20M -Xmn10M -verbose:gc -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC
public class MemoryTest {

    private static final int MB = 1024 * 1024;

    public static void main(String[] args){
        byte[] b1 = new byte[MB];
        byte[] b2 = new byte[2 * MB];
        byte[] b3 = new byte[3 * MB];
        byte[] b4 = new byte[4 * MB];
        byte[] b6 = new byte[2 * MB];
        byte[] b7 = new byte[3 * MB];
    }
}
----

==== ParNew Minor GC

[source,text]
----
[GC (Allocation Failure) [ParNew: 7819K->518K(9216K), 0.0044298 secs] <1>
7819K->6664K(19456K), 0.0044645 secs] <2>
[Times: user=0.02 sys=0.00, real=0.00 secs] <3>
----
<1> 新生代的占用空间从78MB降到5MB, 此时整个新生代大小为92MB.
<2> 整个堆的空间占用从78MB降到66MB, 此时整个堆的大小为20MB.
<3> 本次GC用时0.001秒, 总消耗CPU时间0.02秒.

== QA

[qanda]
创建对象方式?::
* new
* Object.clone()
* Class#newInstance()
* 反序列化
* Unsafe.allocateInstance
如何找到JVM CPU占用高的原因?::
. `jps` 查看JVM进程 `PID`.
. `top -Hp PID` 查看该JVM进程内线程资源占用情况.找到占用资源高的线程 `TID`.
. `printf '%x\n' TID` 将线程id转成16进制数.
. `jstack PID | grep TID -A 10` 查看该线程所在堆栈, 检查堆栈所在代码上的错误.
