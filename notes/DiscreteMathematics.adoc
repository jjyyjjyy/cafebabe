= Discrete Mathematics
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

== 逻辑和证明

=== 命题逻辑

> 命题是一个陈述事实的语句, 它或真或假, 但不能既为真又为假. 如果一个命题是真命题, 用T表示, 假命题用F表示.

> 令 stem:[p] 为一命题, 则 stem:[p] 的否定记作 stem:[notp].

> 令 stem:[p] 和 stem:[q] 为命题, stem:[p]、stem:[q] 的合取记作 stem:[p^^q]. 当p和q都是真命题时, stem:[p^^q] 为真, 否则为假.

> 令 stem:[p] 和 stem:[q] 为命题, stem:[p]、stem:[q] 的析取记作 stem:[pvvq]. 当p和q都是假命题时, stem:[pvvq] 为假, 否则为真.

> 令 stem:[p] 和 stem:[q] 为命题, stem:[p]、stem:[q] 的异或记作 stem:[po+q]. 当p和q中恰好只有1个真命题时为真, 否则为假.

=== 条件语句

> 令 stem:[p] 和 stem:[q] 为命题, 条件语句 stem:[p->q] 代表命题 "如果p,则q". 当stem:[p]为真且stem:[q]为假时, 条件语句 stem:[p->q] 为假, 否则为真.

* stem:[q->p] 称为 stem:[p->q] 的逆命题.
* stem:[notp->notq] 称为 stem:[p->q]的反命题.
* stem:[notq->notp] 称为 stem:[p->q]的逆否命题.

 逆否命题和原命题有相同的真值.
 逆命题和反命题有相同的真值.

> 令p和q为命题, 双条件语句 stem:[pharrq] 代表命题 "p当且仅当q". 当p和q真值相同时, 双条件语句为真, 否则为假.

=== 复合命题的真值表

[cols="6*^"]
|===
| p | q | stem:[notq] | stem:[pvvnotq] | stem:[p^^q] | stem:[(pvvnotq)->(p^^q)]

| T
| T
| F
| T
| T
| T

| T
| F
| T
| T
| F
| F

| F
| T
| F
| F
| F
| T

| F
| F
| T
| T
| F
| F

|===

=== 命题等价式

* 永真式: 命题永远为真.
* 矛盾式: 命题永远为假.
* 可能式: 命题可能为真, 可能为假.

> 如果 stem:[pharrq] 是永真式, 那么 stem:[p和q] 是逻辑等价的, 记为 stem:[p-=q].

.德·摩根律
* stem:[not(p^^q)-=notpvvnotq] `一个析取式的否定是由各个命题的否定合取而成的`
* stem:[not(pvvq)-=notp^^notq] `一个合取式的否定是由各个命题的否定析取而成的`

.恒等律
* stem:[p^^T-=p]
* stem:[pvvF-=p]

.支配律
* stem:[pvvT-=T]
* stem:[p^^F-=F]

.幂等律
* stem:[p^^p-=p]
* stem:[pvvp-=p]

.双重否定律
* stem:[not(notp)-=p]

.交换律
* stem:[pvvq-=qvvp]
* stem:[p^^q-=q^^p]

.结合律
* stem:[(pvvq)vvr-=pvv(qvvr)]
* stem:[(p^^q)^^r-=p^^(q^^r)]

.分配律
* stem:[pvv(q^^r)-=(pvvq)^^(pvvr)]
* stem:[p^^(qvvr)-=(p^^q)vv(p^^r)]

.否定律
* stem:[pvv(notp)-=T]
* stem:[p^^(notp)-=F]

.吸收律
* stem:[pvv(p^^q)-=p]
* stem:[p^^(pvvq)-=p]

.条件命题的逻辑等价式
* stem:[p->q-=notpvvq]
* stem:[p->q-=notq->notp]
* stem:[pvvq-=notp->q]
* stem:[p^^q-=not(p->notq)]
* stem:[not(p->q)-=p^^notq]
* stem:[(p->q)^^(p->r)-=p->(q^^r)]
* stem:[(p->r)^^(q->r)-=(pvvq)->r]
* stem:[(p->q)vv(p->r)-=p->(qvvr)]
* stem:[(p->r)vv(q->r)-=(p^^q)->r]

.双条件命题的逻辑等价式
* stem:[pharrq-=(p->q)^^(q->p)]
* stem:[pharrq-=notpharrnotq]
* stem:[pharrq-=(p^^q)vv(notp^^notq)]
* stem:[not(pharrq)-=pharrnotq]

=== 谓词和量词

****
stem:[ubrace(AA)_("量词")ubrace(x<0)_("约束论域的量词")ubrace((x^2>0))_("谓词")]
****

> 形式为stem:[P(x_1,x_2,...,x_n)]的语句是命题函数P在n元组stem:[(x_1,x_2,...,x_n)]的值, P也称为n元谓词.

> stem:[P(x)]对于x在其论域中的所有值全为真, 即stem:[P(x)]的全程量化. stem:[AAxP(x)]表示stem:[P(x)]的全称量化, 符号stem:[AA]称为全称量词.

> 论域中存在一个stem:[x]使得stem:[P(x)]为真, 即stem:[P(x)]的存在量化. stem:[EExP(x)]表示stem:[P(x)]的存在量化, 符号stem:[EE]称为存在量词. `全称量词的优先级比存在量词的优先级高`

> 论域中存在唯一一个stem:[x]使得stem:[P(x)]为真, stem:[EE!xP(x)]表示stem:[P(x)]的唯一量化, 符号stem:[EE!]称为唯一量词.

