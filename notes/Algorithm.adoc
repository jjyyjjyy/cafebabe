= Algorithm
:author: jy
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared
:sorts: ../algs/src/main/java/me/jy/sort/Sorts.java

.Resource
* https://book.douban.com/subject/19952400[window="_blank"]
* https://book.douban.com/subject/26745780[window="_blank"]

== 数据结构

[.lead]
数据结构就是把数据元素按照一定的关系组织起来的集合, 用来存储数据.

=== 逻辑结构分类

* 集合: 集合结构中数据元素除了属于同一个集合外, 他们之间没有任何的关系.
* 线性: 线性结构中的数据元素存在一对一的关系.
* 树形: 树形结构中的数据元素存在一对多的层次关系.
* 图形: 图形结构的数据元素是多对多的关系.

=== 物理结构分类

* 顺序结构: 把数据存放到地址连续的存储单元里面, 其数据建的逻辑关系和物理关系是一致的.
* 链式结构: 把数据元素存放在任意的存储单元里面, 这组存储单元可以是连续的也可以是不连续的.

== 算法

[.lead]
算法指解题方案的准确而完整的描述, 是一系列解决问题的清晰指令.
算法代表着用系统的方法解决问题的策略机制.

=== 算法分析

* 最坏情况分析: 记T(n)为输入规模为n时的最长运行时间.
* 平均情况分析: 记T(n)为输入规模为n时的所有可能运行时间根据概率加权平均.
* 最好情况分析: 记T(n)为输入规模为n时的最短运行时间.
* 渐近分析: 忽略掉依赖于机器的常量, 检查程序运行的增量, 而不是具体的运行时间.

=== Big O 符号

.表示规则
* 用常数1取代运行时间中的所有加法常数.
* 在修改后的运行次数中, 只保留高阶项.
* 如果最高阶项存在, 且常数因子不为1, 则去除与这个项相乘的常数.

eg: stem:[3n^3+90n^2-5n+4096=O(n^3)]

.常见复杂度比较:

stem:[1 < lgn < sqrtn < n < nlgn < n^2 < n^3 < 2^n < n!]

[#sort]
== 排序

=== 冒泡排序

[source,java]
----
include::{sorts}[tag="bubble-sort"]
----

==== 时间复杂度

* 比较次数: stem:[(n-1) + (n-2) + (n-3)+...+2+1=((n-1+1)*(n-1))/2=(n^2-n)/2]
* 交换次数: stem:[(n-1) + (n-2) + (n-3)+...+2+1=((n-1+1)*(n-1))/2=(n^2-n)/2]
* 总: stem:[O(n^2-n)=O(n^2)]

=== 选择排序

[source,java]
----
include::{sorts}[tag="select-sort"]
----

==== 时间复杂度

* 比较次数: stem:[(n-1) + (n-2) + (n-3)+...+2+1=((n-1+1)*(n-1))/2=(n^2-n)/2]
* 交换次数: stem:[O(n-1)]
* 总: stem:[O((n^2+n)/2-1)=O(n^2)]

=== 插入排序

[source,java]
----
include::{sorts}[tag="insert-sort"]
----

==== 时间复杂度

* 比较次数: stem:[(n-1) + (n-2) + (n-3)+...+2+1=((n-1+1)*(n-1))/2=(n^2-n)/2]
* 交换次数: stem:[(n-1) + (n-2) + (n-3)+...+2+1=((n-1+1)*(n-1))/2=(n^2-n)/2]
* 总: stem:[O(n^2-n)=O(n^2)]

=== 希尔排序

[source,java]
----
include::{sorts}[tag="shell-sort"]
----

=== 归并排序

[source,java]
----
include::{sorts}[tag="merge-sort"]
----

==== 时间复杂度

* 拆分次数: stem:[O(logn)]
* 每次合并比较次数: stem:[O(n)]
* 总: stem:[O(nlogn)]

=== 快速排序

[source,java]
----
include::{sorts}[tag="quick-sort"]
----

==== 时间复杂度

* 拆分次数: 最优stem:[O(logn)], 最坏stem:[O(n)]
* 每次比较交换次数: stem:[O(n)]
* 总: 最好stem:[O(nlogn)], 最坏stem:[O(n^2)]

==== 快速排序和归并排序的区别

* 归并排序将子数组切分后有 *归并* 的动作, 快速排序将子数组排完序后整个数组就自然而然的有序了.
* 归并排序每次切分数组都是等分.

[#list]
== 表

=== 线性表

通过数组存储元素, 可以通过数组索引直接获取元素.

==== 时间复杂度

* get: stem:[O(1)]
* insert: stem:[O(n)]
* remove: stem:[O(n)]

=== 链表

每个元素包含一个指针指向下一个元素.
