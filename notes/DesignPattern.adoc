= Design Pattern
:icons: font
:sectanchors:
:source-highlighter: rouge
:page-layout: docs
:toc: left
:toc-title: 索引

== 1. 定义

> 对在特定场景下解决设计问题的类或对象的描述.

.模式4个要素
* 名称
* 使用场景
* 模式的组成和设计
* 效果(优缺点)

== 2. 类别

|===
| | | 创建型 | 结构型 | 行为型

| 范围
| 类
| Factory Method
| Adapter(类)
a|
* Interpreter
* Template Method

|
| 对象
a|
* Abstract Factory
* Builder
* Prototype
* Singleton
a|
* Adapter(对象)
* Bridge
* Composite
* Decorator
* Facade
* Flyweight
* Proxy
a|
* Chain of Responsibility
* Command
* Iterator
* Mediator
* Memento
* Observer
* State
* Strategy
* Visitor

|===

== 3. 作用

* 创建型:
** 类: 将对象的部分创建工作延迟到子类
** 对象: 将对象的部分创建工作延迟到另一个对象中
* 结构型:
** 类: 使用继承机制来组合类
** 对象: 描述了对象的组装方法
* 行为型:
** 类: 使用继承描述算法和控制流
** 对象: 描述一组对象协作来完成单个对象无法完成的任务

== 4. 面向对象设计原则

* Single Responsibility Principle: 单一职责原则

 一个类只负责一个功能领域的相应职责.如常用的代码分层: xxRepository负责db/xxService负责逻辑处理

* Open-Closed Principle: 开闭原则

 一个实体类应该尽量在不修改原有代码的基础上扩展.

.OCP(新增Chart不会修改AbstractChartDisplay类的代码)
[plantuml, diagram-classes, svg]
....
interface Chart{
+ void display()
}
class AbstractChartDisplay{
- chart: Chart
+ void setChart(Chart chart)
}
class FooChart{
}
class BarChart{
}

Chart <|.. FooChart
Chart <|.. BarChart
Chart <|.. AbstractChartDisplay
....

* Liskov Substitution Principle: 里氏替换原则

 在程序定义时尽量使用父类类型, 在运行时再去确定子类类型.
 在类设计时, 尽量把子类的方法抽到父类里面.

* Dependency Inversion Principle: 依赖倒转原则

 针对接口编程, 而不是实现类.

* Interface Segregation Principle: 接口隔离原则

 使用多个专门的接口, 而不是单一的接口.

* Composite Reuse Principle: 合成复用原则

 尽量使用对象组合, 而不是继承来达到复用的目的.
 Has-a 使用组合, Is-a 使用继承

* LeastKnowledge Principle: 最小知识原则

 尽量减少对象之间的交互.


== 5. 创建型模式

=== 简单工厂(静态工厂)

 定义一个工厂类, 根据不同的参数返回不同的类型. 被创建的对象类型通常具有共同的父类.

=== 工厂方法


