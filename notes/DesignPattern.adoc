= Design Pattern
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared
:code-path: ../design-pattern/src/main/java/me/jy/

== 设计模式概述

=== 定义

> 对在特定场景下解决设计问题的类或对象的描述.

=== 特性

* 代码重用性: 相同功能的代码不用多次编写.
* 可读性: 代码规范性, 便于其他程序员的阅读和理解.
* 可扩展性: 便于增加新的功能.
* 可靠性: 当增加新的功能后, 对原有的功能没有影响.
* 高内聚低耦合: 每个功能模块内部关系紧密, 但是模块之间不会相互影响.

=== 要素

* 名称
* 使用场景
* 模式的组成和设计
* 效果(优缺点)

=== 原则

==== 单一职责原则

一个类/方法应该只负责一项职责.
降低类/方法的复杂度, 从而降低改动造成的风险.

==== 接口隔离原则

使用方不应该依赖它不需要的接口.
一个类对另一个类的依赖应该建立在最小的接口上. 可以将一个接口分成几个小接口.

==== 依赖倒转原则

底层模块尽量要有抽象类和接口. 而高层模块不应该直接依赖底层模块的具体实现类, 而应该依赖其抽象.
尽量面向接口编程.

==== 里氏替换原则

所有引用父类的地方必须能够透明地使用其子类的对象.
在子类中尽量不要重写父类的方法, 或者使用聚合/组合/依赖来解决问题.

==== 开闭原则

对功能提供者开放扩展, 对使用方关闭修改.
尽量在原有类上新增功能.

==== 迪米特原则

尽量减少类之间的交互. 一个类对自己依赖的类知道的越少越好.
尽量避免在局部变量中直接使用其他类.

==== 合成复用原则

尽量使用聚合/组合/依赖的方式使用与自己不相关的类的功能, 而不是使用继承.

== UML

> 用来描述系统中的类/对象本身的组成和类和类之间的各种静态关系.

=== 类之间的关系

* 依赖: 一个类用到了另外一个类, 则两个类之间存在依赖关系. (成员属性/返回类型/方法参数类型/局部变量类型)
* 关联: 1对1/1对多/多对多的关系.
* 泛化: 继承一个类.
* 实现: 实现一个接口.
* 聚合: 表示整体和部分的关系. 整体和部分可以分别运行. (通过set方法设置依赖类的对象)
* 组合: 表示整体和部分的关系. 整体和部分不可以分开. (实例化时就初始化依赖的类)

== 设计模式分类

* 创建型: 将对象的部分创建工作延迟到具体实现类.
* 结构型: 描述了对象的依赖方法.
* 行为型: 描述一组对象协作来完成单个对象无法完成的任务.

[plantuml, design-patterns, svg]
....
@startmindmap

!include charts/global/stylesheet.iuml

* 设计模式

left

** 创建型
*** 单例模式
*** 简单工厂模式
*** 工厂方法模式
*** 抽象工厂模式
*** 原型模式
*** 建造者模式
** 结构型
*** 适配器模式
*** 桥接模式
*** 装饰模式
*** 组合模式
*** 外观模式
*** 享元模式
*** 代理模式

right

** 行为型
*** 模板方法模式
*** 命令模式
*** 访问者模式
*** 迭代器模式
*** 观察者模式
*** 中介者模式
*** 备忘录模式
*** 解释器模式
*** 状态模式
*** 策略模式
*** 责任链模式

@endmindmap
....

== 创建型模式

[#singleton]
=== Singleton模式

采取一定的方法保证整个软件系统中对某个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法.
内部提供一个静态的工厂方法, 获取单个实例.

==== 使用场景

* 系统中该类不需要多个实例.
* 重量级对象.
* 工具类.

==== 结构

[plantuml,singleton,svg]
.单例模式UML
....

!include charts/global/stylesheet.iuml

class Singleton {
  - Singleton INSTANCE
  + Singleton getInstance()
}

Singleton o-- Singleton
....

==== 优点

* 节约系统资源.
* 限制了对实例的访问.

==== 缺点

* 扩展困难

==== 单例模式写法

[source,java]
.饿汉式 - 静态常量
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-lazy-1"]
----

[source,java]
.饿汉式 - 静态代码块
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-lazy-2"]
----

[source,java]
.懒汉式 - 同步方法
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-eager-1"]
----

[source,java]
.懒汉式 - 同步代码块双重检查锁
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-eager-2"]
----

[source,java]
.静态内部类
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-inner-static-class"]
----

[source,java]
.枚举
----
include::{code-path}/_4_singleton/SingletonProduct.java[tag="singleton-enum"]
----

[#simple-factory]
=== 简单工厂模式

定义一个工厂类, 根据不同的参数返回不同的类型. 被创建的对象类型通常具有共同的父类.

==== 使用场景

调用方知道创建对象需要的参数, 不关心对象的创建过程.

==== 结构

[plantuml,simple-factory,svg]
.简单工厂模式UML
....

!include charts/global/stylesheet.iuml

abstract class Product
class ConcreteProductA
class ConcreteProductB
class ProductFactory {
  + Product getProduct(String type)
}

Product <.. ConcreteProductA
Product <.. ConcreteProductB
ProductFactory -> Product

....

==== 优点

* 将对象的创建和对象的使用分离开, 客户端无需知道具体的创建逻辑.

==== 缺点

* 工厂类职责过重, 如果工厂类出现问题, 就会影响整个系统.
* 系统扩展困难, 一旦添加新的产品就要修改工厂逻辑, 违反了开闭原则.

[#factoy-method]
=== Factory Method模式

定义一个创建对象的接口, 让子类决定将哪个类实例化.

==== 使用场景

调用方不知道它需要的对象的类型.

==== 结构

.工厂方法模式UML
[plantuml,factoy-method,svg]
....

!include charts/global/stylesheet.iuml

abstract class Product
class ConcreteProductA
class ConcreteProductB
interface ProductFactory {
  + Product create()
}
class ConcreteProductAFactory {
  + ConcreteProductA create()
}
class ConcreteProductBFactory {
  + ConcreteProductB create()
}
Product <|-- ConcreteProductA
Product <|-- ConcreteProductB
ProductFactory <.. ConcreteProductAFactory
ProductFactory <.. ConcreteProductBFactory
ConcreteProductA <-- ConcreteProductAFactory
ConcreteProductB <-- ConcreteProductBFactory
....

==== 优点

* 客户端只需要关心创建产品需要的工厂, 无需关心创建细节.

==== 缺点

* 系统文件个数增加

[#abstract-factory]
=== Abstract Factory模式

==== 使用场景

需要多种类型的多种对象, 且每次只使用同一类型的对象.

==== 结构

.抽象工厂模式UML
[plantuml,abstract-factoy,svg]
....

!include charts/global/stylesheet.iuml

interface ProductA
interface ProductB
class ConcreteProductA1
class ConcreteProductA2
class ConcreteProductB1
class ConcreteProductB2
interface ProductFactory {
  + ProductA createA()
  + ProductB createB()
}
class ConcreteProductFactory1 {
  + ConcreteProductA1 createA()
  + ConcreteProductB1 createB()
}
class ConcreteProductFactory2 {
  + ConcreteProductA2 createA()
  + ConcreteProductB2 createB()
}
ProductA <.. ConcreteProductA1
ProductA <.. ConcreteProductA2
ProductB <.. ConcreteProductB1
ProductB <.. ConcreteProductB2
ProductFactory <.. ConcreteProductFactory1
ProductFactory <.. ConcreteProductFactory2

ConcreteProductA1 <-- ConcreteProductFactory1
ConcreteProductB1 <-- ConcreteProductFactory1
ConcreteProductA2 <-- ConcreteProductFactory2
ConcreteProductB2 <-- ConcreteProductFactory2
....

==== 优点

* 增加一个产品族的时候只需要增加一个工厂类就行了.

==== 缺点

* 增加一个产品需要修改所有的工厂类.

[#prototype]
=== 原型模式

使用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象.

==== 使用场景

创建大量内容相同的对象.

==== 结构

.原型模式UML
[plantuml,prototype,svg]
....

!include charts/global/stylesheet.iuml

class Prototype {
  + Prototype clone()
}

Prototype <--Prototype
....

==== 优点

* 简化对象的创建过程, 提高新对象的创建效率

==== 缺点

* 为了deep clone, 对象的每一个属性都必须实现deep clone.

=== Builder模式

提供Builder类组装对象

==== 使用场景

组装的类属性很多, 创建过程复杂, 可以引入builder简化客户端调用.

==== 组成

.建造者模式UML
[plantuml,builder,svg]
....

!include charts/global/stylesheet.iuml

class Product
abstract class Builder {
  # Builder a()
  # Builder b()
  # Builder c()
  # Product build()
}
class ConcreteBuilder {
  + ConcreteBuilder a()
  + ConcreteBuilder b()
  + ConcreteBuilder c()
  + Product build()
}
Builder <|-- ConcreteBuilder
Product <- ConcreteBuilder
....

==== 优点

* 隔离复杂对象的创建和使用, 并使得相同的创建过程可以创建不同的对象.

==== 缺点

* 如果产品内部变化复杂, 则会导致需要定义很多具体的建造者来实现这些变化, 导致系统臃肿.

== 结构型模式

[#adapter]
=== Adapter模式

 继承Target类, 使用另外的Adaptee类重写Target类方法

==== 使用场景

 没有Target类的代码(需要框架使用者去扩展) / 重用Adaptee类代码

==== 结构

.对象适配器模式UML
[plantuml,adapter-obj,svg]
....
interface Target{
+ void call()
}
class Adaptee{
+ void anotherCall()
}
class Adapter{
- Adaptee adaptee
+ void call()
}
Target <.. Adapter
Adapter -> Adaptee
....

.类适配器模式UML
[plantuml,adapter-class,svg]
....
interface Target{
+ void call()
}
class Adaptee{
+ void call()
}
class Adapter{
+ void call()
}
Target <.. Adapter
Adaptee <.. Adapter
....

==== 优点

* 将目标类和实现解耦
* adaptee类可以重用
* 可以集成多个适配类

==== 缺点

* 如果Target不是接口, 则最多只能继承一个Target.

=== Bridge模式

 将复杂系统拆成多个维度(把继承转化为组合)

==== 使用场景

 系统中某个类存在多个维度, 可以将各个模式拆分出来, 使其可以单独扩展.

==== 结构

.bridge模式UML
[plantuml,bridge,svg]
....
class Implementor{
+ void operate()
}

class Abstraction{
- Implementor impl
+ void setImplementor(Implementor)
+ abstract void call()
}

class AbstractionA{
+ void call()
}

Abstraction <|-- AbstractionA
Abstraction -> Implementor
....

==== 优点

* 能灵活扩展一个维度而不影响其他维度

==== 缺点

* 难以分离维度

=== Composite模式

 定义一个抽象结构类, 包含所有的组件方法, 组合所有子组件和容器组件.

==== 使用场景

 希望忽略整体和部分的差异, 让客户端一致地对待他们

==== 结构

.composite模式UML
[plantuml,composite,svg]
....
class Component{
+ void operate()
}

class Leaf extends Component{
+ void operate()
}

class Composite extends Component{
+ void add(Component)
+ void remove(Component)
+ void operate()
}

....

==== 优点

* 可以清楚地定义分层次的复杂对象.
* 方便增加组件
* 客户端可以无需关心子组件的层次结构, 统一处理.

=== Decorator模式

 在不改变原有类的基础上, 通过继承扩展现有的功能

==== 使用场景

 给单个对象扩展功能

==== 结构

.Decorator模式UML
[plantuml,decorator,svg]
....
class Component{
+ void operate()
}
class ConcreteComponent extends Component{
+ void operate()
}
class Decorator extends Component{
+ void operate()
}
class ConcreteDecoratorA extends Decorator{
+ void operate()
}
class ConcreteDecoratorB extends Decorator{
+ void operate()
}

Decorator -> ConcreteComponent
....

==== 优点

* 减少了子类的个数, 扩展性提高
* 可以通过不同的装饰创造出不同行为的组合.

==== 缺点

* 产生较多的对象

=== Facade模式

 为子系统提供统一的入口

==== 使用场景

 客户端程序与子系统有很大的关联性.

==== 结构

.Facade模式UML
[plantuml,facade,svg]
....
class SystemA{
+ void actionA()
}
class SystemB{
+ void actionB()
}
class SystemC{
+ void actionC()
}
class Facade{
+ void operate()
}

SystemA <- Facade
SystemB <- Facade
SystemC <- Facade
....

==== 优点

* 降低客户端与子系统的耦合度.
* 一个子系统的修改与其他系统没有影响

=== FlyWeight模式

 实现多个细粒度对象的复用. 使用工厂获取对象.

==== 使用场景

 对象数量较多但对象内部状态统一.

==== 结构

.FlyWeight模式UML
[plantuml,flyWeight,svg]
....
class Flyweight{
+ void operate(ExternalState)
}
class ConcreteFlyweight{
+ void operate(ExternalState)
}
class FlyweightFactory{
- Map flyWeights
+ Flyweight get(InternalState)
}

Flyweight <|-- ConcreteFlyweight
....

==== 优点

* 可以极大减少内存中对象的数量.
* 内外部状态独立.

==== 缺点

* 分离内外部状态, 使系统更复杂.

=== Proxy模式

 给某一个对象提供一个代理对象, 由他控制对原对象的访问.

==== 使用场景

 无法直接访问某个对象, 或者访问困难.

==== 结构

.Proxy模式UML
[plantuml,proxy,svg]
....
interface Subject{
+ void request()
}
class ConcreteSubject{
+ void request()
}
class ProxyObject{
+ void customRequest()
}
Subject <|.. ConcreteSubject
Subject <|.. ProxyObject
ConcreteSubject <- ProxyObject
....

==== 优点

* 协调调用者和被调用者, 降低系统耦合度.

== 行为型模式

=== Responsibility Of Chain模式

==== 使用场景

 系统中有多个对象处理请求, 所有对象构成链式结构.

==== 结构

.Responsibility Of Chain模式UML
[plantuml,chain-of-responsibility,svg]
....
class Handler{
- Handler successor;
+ void request()
}
class ConcreteHandlerA{
+ void request()
}
class ConcreteHandlerB{
+ void request()
}
Handler <|-- ConcreteHandlerA
Handler <|-- ConcreteHandlerB
Handler <--|> Handler
....

==== 优点

* 职责链中的对象无需关心链的结构
* 新增或者删除handler的时候只需要修改客户端类.

==== 缺点

* 客户端任重而道远.

=== Command模式

==== 使用场景

 向对象发送请求, 但不知道谁接收并处理请求.

==== 结构

.Command模式UML
[plantuml,command,svg]
....

class ReceiverA {
+ void action()
}
class ReceiverB {
+ void action()
}

abstract class Command {
+ void execute()
}

class ConcreteCommandA {
}

class ConcreteCommandB {
}

Command <|-- ConcreteCommandA
Command <|-- ConcreteCommandB
ReceiverA <- ConcreteCommandA
ConcreteCommandB -> ReceiverB
....

==== 优点

* 调用者和接收者解耦.

==== 缺点

* 系统需要大量的命令类.
