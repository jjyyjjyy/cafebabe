= Assembly
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

.Resources
* https://book.douban.com/subject/25726019[window="_blank"]

== 总线

总线分为地址总线, 数据总线和控制总线.

* n根地址总线可以寻址 stem:[2^n]个内存单元.
* n根数据总线可以一次性传输 stem:[n/8]个字节的数据.
* 控制总线的宽度决定了CPU对外部器件的控制能力.

== CPU

=== 内存地址

对于16位CPU, 物理地址 = 段地址 * 16 + 偏移地址.
一个段的长度最大为64KB(偏移地址数量).

=== 寄存器

==== 数据寄存器

AX BX CX DX

每个寄存器都可以分为*H和*L, 各代表高低8位.

==== 段寄存器

> 提供内存单元的段地址

CS DS SS ES

NOTE: 8086CPU不支持将数据直接送入到段寄存器, 只能送入一个数据寄存器/内存空间的值.
段寄存器的值可以送入到数据寄存器/内存空间中.

==== 指令指针寄存器

> 保存下一条将要指定的指令地址.

IP

.使用jmp修改IP寄存器的值:
* jmp <cs>:<ip>. `jmp FFFFH,3`
* jmp <ip> `jmp ax`

=== 指令执行流程

. CPU从 stem:[CS*16+IP] 中读取指令, 读取到的指令放入指令缓冲器.
. IP+=读取到的指令长度.
. 执行指令.
. 重复步骤1.

CS初始值0xFFFFH, IP初始值0x0000H,内存单元0xFFFF0H保存第一条要被执行的指令地址.

=== 栈寄存器

SS:SP指向栈顶元素, push和pop指令执行时, CPU从SS和SP中得到栈顶地址.

== Check points

=== 1.1

. 13
. stem:[1024,0,1023]
. stem:[2^13,2^10]
. stem:[2^30,2^20,2^10]
. stem:[64,1,16,4]
. stem:[1,1,2,2,4]
. stem:[512,256]
. 二进制

=== 2.1

. 计算寄存器内的值
.. f4a3H
.. 31a3H
.. 3123H
.. 6246H
.. 826CH
.. 6246H
.. 826CH
.. 04D8H
.. 0482H
.. 6C82H
.. D882H
.. D888H
.. D810H
.. 6246H

. 求2的4次方

[source,x86asm]
----
mov ax, 2
add ax, ax
add ax, ax
add ax, ax
----

=== 2.2

. stem:[00010H,1000FH]
. stem:[1001H,2000H]

=== 2.3

IP被修改过4次, 最后IP的值为0000H

=== 3.1

. 计算相关寄存器的值
.. 2662H
.. E626H
.. E626H
.. 2662H
.. D6E6H
.. 0D48H
.. 3C14H
.. 0
.. 00E6H
.. 0
.. 0026H
.. 001CH

. 写出汇编指令

[source,x86asm]
----
mov ax,6622H  # IP=3
jmp 0ff0:0100 # IP=8
mov ax,2000H # IP=11, ax=2000H
mov ds,ax # IP=13, ds=2000H
mov ax,[0008] #IP=16, ax=C389H
mov ax,[0002] #IP=19
----

=== 3.2

. 补全逆序复制代码1

[source,x86asm]
----
mov ax,2000H
mov ss,ax
mov sp,10H
----

. 补全逆序复制代码2

[source,x86asm]
----
mov ax,1000H
mov ss,ax
mov sp,0
----

