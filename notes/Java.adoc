= Java
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

.Resources
* https://book.douban.com/subject/30133440[, window="blank"]
* https://book.douban.com/subject/34907497[, window="blank"]
* https://book.douban.com/subject/26740520[, window="blank"]

== 数据类型

* 基本数据类型
** byte stem:[-2^7 ~ 2*7-1]
** short stem:[-2^15~2^15-1]
** int stem:[-2^31~2^31-1]
** long stem:[-2^63~2^63-1]
** boolean
** char `Unicode` stem:[0~2^16-1]
** float `IEEE754`
** double `IEEE754`

* 引用数据类型
** Class
** Interface
** Array

== 位运算符

* `<<` 左移运算符, 向左移n位, 右边补0.
* `>>` 带符号右移, 向右移n位, 左边补第1位的值.
* `>>>` 无符号右移, 向右移n位, 左边补0.

== 字符编码

=== ASCII

用0~127分别表示128个字符.
1个字节大小

=== Unicode

给每个字符分配一个16进制的数字编号, 数字编号范围从0x000000到0x10FFFF.
但是Unicode本身没有定数字编号到二进制之间的转换关系.

[plantuml,unicode,svg]
....
@startuml
2进制 -> 16进制: UTF-8
2进制 -> 16进制: UTF-16
2进制 -> 16进制: UTF-32
16进制 -> 字符 : Unicode
@enduml
....

==== UTF-8

.UTF-8 使用一至四个字节为每个字符编码
* 对于单字节字符, 首位为0, 后面7位表示字符
* 对于多字节字符, 第一个字节以n个1和一个0开头, 其他字节以10开头, 再从后往前补齐二进制位.

==== UTF-16

.UTF-16 使用二或四个字节为每个字符编码
* 存在一个起始字节序列, `FFFE/FEFF` 标识小端/大端.
* Unicode码小于U+10000的，直接转换为UTF-16双字节序列.
* 大于等于U+10000的, 先减去0x10000, 再分别分成10个比特位.
高位前面用 `110110` 填充, 低位前面用 `110111` 填充.

==== UTF-32

.UTF-32 使用四个字节为每个字符编码
. 存在一个起始字节序列, `0000FEFF/FFFE0000` 分别标识大端/小端.
. 将Unicode码分成四个字节, 高位不足的补0.

|===
| 字符 |Unicode | UTF-8 | UTF-16 | UTF-32

| A
| 00000000,01000001
| 01000001
| 00000000,01000001
| 00000000,00000000,00000000,01000001

| ؆
| 00000110,00000110
| 11011000,10000110
| 00000110,00000110
| 00000000,00000000,00000110,00000110

| 严
| 01001110,00100101
| 11100100,10111000,10100101
| 01001110,00100101
| 00000000,00000000,01001110,00100101

| 𠀲
| 11011000,01000000,11011100,00110010
| 11110000,10100000,10000000,10110010
| 11011000,01000000,11011100,00110010
| 00000000,00000010,00000000,00110010

|===

== 浮点数

=== 浮点数的表示方法

stem:[V=(-1)^s*M*2^E]

* S: 符号位, 决定是正数还是负数, 1代表负数.
* E: 阶码, 值是2的幂, 它的作用是对浮点数加权.
* M: 尾数.

=== 浮点数的存储方法

一个浮点数被分为三部分存储:

* `s` : 符号位标识正数还是负数.
* `exp` : k位阶码字段, 与E相关.Bias=stem:[2^(k-1)-1]
** 单精度为8位.
Bias=127.
** 双精度为11位.
Bias=1023.
* `frac` : n位小数字段, 与M相关.

=== 浮点数的分类

==== 规范化浮点数

[.lead]
`exp` 部分不全为0或1.

E=exp-Bias.
M=frac+1. (规范化浮点数首位为1, 所以M=frac+1)

如 0.10111, 可以表示为 stem:[1.0111* 2^(-1)] , frac=0.0111, M=frac+1=1.0111

==== 非规范化浮点数

[.lead]
`exp` 部分全为0.

E=1-Bias, M=frac.

==== 无穷大

[.lead]
`exp` 部分全为1, `frac` 部分全为0.

==== NaN

[.lead]
`exp` 部分全为1, `frac` 部分不等于0.

== 面向对象

=== 可见性

private << default << protected << public

* `private` : 只能在类的内部访问.
* `default` : 只能被同一个包中其他类访问.
(子包也不能访问)
* `protected` : 可以被子类或同一个包中其他类访问.
* `public` : 可以被任意类访问.

=== 重载

重载指同一个类内方法名称相同, 但方法签名(参数数量/类型)不同.

=== 重写

* 参数列表必须相同.
* 子类可以提升方法的可见性.
* 子类抛出的checked异常必须与父类相同, 或是父类抛出checked异常的子类.
* 子类方法的返回值可以是父类返回值类型的子类.

=== 接口default方法判定

* Class优先.
* 子接口优先.
* 无法确定需用 `类名.super` 显式调用.

NOTE: Class#getDeclaredMethods不包含从父类继承过来的方法.

=== 内部类

==== 静态内部类

静态内部类可以访问外部类的private静态变量和方法, 但不可以访问外部类的实例变量或方法.

==== 成员内部类

* 成员内部类可以访问外部类的实例变量和方法.
* 成员内部类不可以自己定义静态变量和方法.

==== 匿名内部类

匿名内部类方法参数属于final, 不能修改值/引用.

== 异常

=== Checked Exception

继承Exception但不是RuntimeException的异常类.
需要程序手动处理.

=== Unchecked Exception

继承RuntimeException/Error的异常类.
程序可以选择捕获处理, 也可以不处理.

== 注解

=== 重复注解

`@Repeatable(xxx.class) & getAnnotationsByType(xxx.class);`

=== Retention

|===
|   | 源码 | 字节码文件 | 运行时获取

| Source
| √
|
|
| Class
| √
| √
|

| Runtime
| √
| √
| √
|===

=== Target

* Type: 类、接口、注解、枚举
* Field: 字段
* Method: 方法
* Parameter: 方法参数
* Constructor: 构造函数
* Local_Variable: 局部变量
* Annotation_Type: 只能用在注解上
* Package: 包声明上
* Type_Parameter: 类参数, 尚未参透
* Type_Use: 用在任何声明&定义的类型处

== 枚举

=== 枚举类方法

* values() 返回所有枚举常量
* valueOf(String) 返回名字对应的枚举常量
* name() 返回枚举常量名字
* oridinal() 返回枚举常量的序号
* compareTo() 比较枚举常量的序号

=== EnumSet

* EnumSet.allOf(Enum.class) 返回包含所有枚举常量的集合
* EnumSet.rangOf(EnumA,EnumB) 返回A与B之间所有的枚举常量, 包括边界

=== EnumMap

* EnumMap#entrySet 为空,forearch用不了, 只能手动put ==to fix==

== 序列化

. serialVersionUID标识类的序列化的版本号,如果反序列化时当前类的版本号与序列化的二进制流对象的版本号不一致则会抛出异常.
. 序列化时会调用readObject方法,反序列化时会调用writeObject方法.
. 序列化再反序列化后静态成员变量值为最新的.

== 泛型

. 上界通配符 `<? extends T>` 只能get到泛型边界类型
. 下界通配符 `<? super T>` 只能get到Object类型, add时只能传泛型边界的类型.
. 取不到一个类定义的泛型类型(T), 只能取其子类或父类具体的泛型类型(Long,String...).

[source,java]
----
include::../basic-knowledge/src/main/java/me/jy/lang/generic/GenericDemo.java[]
----

== 多线程

=== 创建线程的方式

* 继承Thread然后实例化这个对象.
* 创建Runnable对象, 使用 `new Thread(Runnable)` 构造函数创建线程对象.
* 创建Callable对象, 使用 `new FutureTask(Callable)` 构造函数创建线程对象.

=== 线程状态

* NEW
* RUNNABLE
* BLOCKED
* WAITING
* TIMED_WAITING
* TERMINATED

=== 常见方法

==== run

调用Runnable对象的run方法.
如果使用继承Thread的方式来创建线程对象, 则会重写run方法.

==== start

start方法会运行当前创建出来的线程, 线程状态从 `NEW` 变为 `RUNNABLE` .
start方法不能重复调用.

==== _sleep_

当前线程从 `RUNNABLE` 变为 `TIME_WAITING` 状态.

如果调用方调用了这个线程的 `interrupt()` 方法, 则 `sleep` 方法会抛出 `InterruptedException` .

==== _yield_

当前线程从 `RUNNING` 变为 `RUNNABLE` 状态, 具体由操作系统实现, `Thread.State` 中均为 `RUNNABLE` 枚举值.

==== join

等待指定线程执行完.

`join` 是使用 `wait` 来实现的.

==== interrupt

打断 `sleep/wait/join` 的线程, 设置 `interrupted` 标志位为true.

==== _interrupted_

返回当前线程的打断标志, 然后重置为false.

==== object::wait

当前线程从 `RUNNABLE` 变为 `BLOCKED` 状态.

==== object::notify

唤醒另外一个等待线程锁的代码块.

[WARNING]
====
* 每一条线程都有自己的栈空间,拥有一份方法参数、局部变量和返回值的拷贝.每一个线程都有自己的一份标识信息,包括线程名、线程优先级、线程是否存活、线程执行状态、守护线程标识等.
* 线程内异常无法在外层try-catch, 只能设置Thread的UncaughtExceptionHandler wait()释放对象锁,sleep()不释放.
====

=== volatile

* 保证有序性和可见性
* 不保证原子性

=== synchronized

==== 使用方式

* 修饰成员方法
* 修饰静态方法
* 代码块指定修饰对象

==== 实现原理

synchronized基于Monitor实现. 在代码块前后和异常表 `to` 之后分别插入 `monitorenter/monitorexit` 指令.

Monitor锁对象组成:
* `Owner` 持有该Monitor锁的对象.
* `EntryList` 保存竞争该Monitor锁的 `Blocked` 状态的对象.
* `WaitSet` 保存竞争该Monitor锁的 `Waiting` 状态的对象.

. 线程1竞争锁时发现Owner为空, 则设置Owner为线程1.
. 线程2竞争锁, 发现Owner不为空, 则进入EntryList等待唤醒.
. 线程1释放锁, Owner置为空, 唤醒EntryList里的一个线程, 设置为Owner.

==== 锁升级的过程

===== MarkWord

无锁: stem:[ubrace("unused")_(25位) ubrace("hash")_(31位) ubrace("unused")_(1位) ubrace("age")_(4位) ubrace("bias_lock")_(1位)^0 ubrace("lock")_(2位)^01]
偏向锁: stem:[ubrace("thread")_(54位) ubrace("epoch")_(2位) ubrace("unused")_(1位) ubrace("age")_(4位) ubrace("bias_lock")_(1位)^1 ubrace("lock")_(2位)^01]
轻量级锁: stem:[ubrace("ptr_lock_record")_(62位) ubrace("lock")_(2位)^00]
重量级锁: stem:[ubrace("ptr_monitor")_(62位) ubrace("lock")_(2位)^10]

无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

===== 轻量级锁

.加锁
. 每次竞争锁时, 线程栈帧中都会生成一个新的 `LockRecord` 对象(`LockRecord地址 00` )和指向持有该线程锁的对象引用地址,
. 第一次有对象竞争这个线程的锁时, 把 `LockRecord` 地址和对象的MarkWord( `hash age bias 01` )cas互换, 后面两位设置为 `00` , 将栈帧中的对象引用指向这个对象.
. 如果cas失败:
.. 锁竞争对象MarkWord中LockRecord地址指向当前线程, 则表示该次竞争属于锁重入, cas会设置自己的LockRecord地址为null, 将栈帧中的对象引用指向这个对象.
.. 已经有其他线程持有了本线程的锁, 则进入 *锁膨胀* 的过程.

.解锁
. 每次释放锁时cas检测是否栈顶的LockRecord对象记录的值是否为null:
.. 如果为null, 表示有重入, 将该LockRecord对象出栈.
.. 如果不为null, 用cas更新对象的MarkWord为LockRecord中的hash.
... 更新成功, 表示解锁成功, 出栈.
... 更新失败, 表示该LockRecord指向对象持有的是重量级锁.

===== 重量级锁

.加锁
. 线程cas更新对象MarkWord里的hash值为自己的LockRecord地址值失败, 则表示已经有其他线程持有了这个对象的轻量级锁, 此时进入锁膨胀的过程.
. 申请一个Monitor对象
.. 将Monitor的Owner地址指向此时MarkWord里的LockRecord地址.
.. 将对象的MarkWord设置为Monitor对象的地址,
.. 将当前线程放入Monitor的EntryList里.

.解锁
. 将Monitor的Owner置为null.
. 从EntryList里唤醒一个线程让其持有这个Monitor锁, 设置为Owner.

===== 自旋锁

重量级锁加锁失败时, 会自旋尝试多次, 尝试失败后才会把自己加到EntryList里.

===== 偏向锁

对象初始化时, MarkWord最后三位设置为 stem:[101], 第一次竞争锁时线程id存储在MarkWord的前54位里, 下一次该线程竞争锁时可以直接进入代码同步块.

* `-XX:BiasedLockingStartupDelay=0` 设置偏向锁不延迟打开.

.偏向锁的撤销
* JVM关闭偏向锁的功能. `-XX:-UseBiasedLocking`
* 有其他线程竞争锁.
* 调用wait/notify, 因为此时需要依赖Monitor对象的WaitSet.

=== Park

每个线程都关联一个Parker对象, 由 `_counter, _cond, _mutex` 三部分组成.

.LockSupport.park()
* `_counter` 为0时, 进入阻塞状态.
* `_counter` 为1时, 不进入阻塞状态, 继续运行.
* 重置 `_counter` 为0.

.LockSupport.unPark(Thread)
* 如果线程处于阻塞状态, 就唤醒线程继续运行.
* 如果线程处于运行状态, 则设置 `_counter` 为1, 线程继续运行.

=== CAS

==== 实现原理

基于CPU指令 `cmpxchg` 比较并交换, 如果提供的值与获取到的值相等则赋值成功, 否则赋值失败.

=== Executor

==== 分类

* ThreadPoolExecutor
* ForkJoinPool
* ScheduledThreadPoolExecutor

==== 运行流程

. 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
. 如果当前线程池中的线程数目大于等于corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
. 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
. 如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

=== ThreadPoolExecutor

==== 线程池状态

|===
| 状态名 | 标志 | 是否接收新任务 | 是否处理阻塞队列任务 | 说明

| RUNNING
| 111
| √
| √
|

| SHUTDOWN
| 000
| ×
| √
| 不会接收新的任务, 只会处理阻塞队列中剩余的任务.

| STOP
| 001
| ×
| ×
| 中断正在执行的任务, 抛弃阻塞队列中的任务.

| TIDYING
| 010
| ×
| ×
| 任务全部执行完毕, 活动线程为0, 即将进入终结状态.

| TERMINATED
| 011
| ×
| ×
| 终结状态

|===

==== 使用

* FixedThreadPool: 核心线程数等于最大线程数, 使用无界队列存储多余任务, 适用于任务量已知且耗时的场景.
`new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())`
* CachedThreadPool: 没有核心线程数, 适用于任务执行时间短且密集的场景.
`new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());`
* SingleThreadPool: 核心线程数和最大线程数都为1, 适用于希望任务排队串行执行的场景.
`new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()))`

==== 关闭

* `shutdown()`: 线程池状态更新为 `SHUTDOWN` , 只执行所有已提交的任务(包括阻塞队列里的任务), 不再接受新的任务.

[source,java]
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/ShutdownDemo.java[tag=shutdown]
----

<1> 线程池状态变为SHUTDOWN, 只会执行已经提交的任务.
<2> reject任务.
<3> 等待任务1/2/3执行完

* `shutdownNow()`: 调用所有核心线程的interrupt()方法, 并直接返回阻塞队列里的任务.

[source,java]
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/ShutdownDemo.java[tag=shutdownNow]
----

<1> 调用所有核心线程的interrupt()方法, 并直接返回阻塞队列里的任务.
<2> 返回任务3.
<3> reject任务.
<4> 等待任务1/2执行完

=== JUC工具类

==== AbstractQueuedSynchronizer

* `tryAcquire` 尝试获取锁
* `tryRelease` 尝试释放锁

==== ReentrantLock

.ReentrantLock与synchronized对比
* ReentrantLock和synchronized都支持可重入.
* synchronized使用C++实现的, ReentrantLock是JDK类库实现的.
* ReentrantLock可中断, synchronized需要手动判断 `interrupted` 标志位.
* ReentrantLock可以设置超时时间.
* ReentrantLock可以设置为公平锁.
* ReentrantLock支持多个条件变量.

==== Semaphore

==== CountDownLatch

==== CyclicBarrier

=== CompletableFuture

== ClassLoader

* loadClass 实现双亲委托模型
* findClass 实现类文件读取

== Stream

[.lead]
一个完整的操作是<数据来源,操作,回调函数>构成的三元组.
Stream中使用Stage的概念来描述一个完整的操作, 并用某种实例化后的PipelineHelper来代表Stage, 将具有先后顺序的各个Stage连到一起, 就构成了整个流水线.

=== 中间操作

. 无状态:
.. unordered
.. filter
.. map
.. mapToInt
.. mapToLong
.. mapToDouble
.. flatMap
.. flatMapToInt
.. flatMapToLong
.. flatMapToDouble
.. peek
. 有状态
.. distinct
.. sorted
.. limit
.. skip

=== 结束操作

. 非短路操作
.. forEach
.. forEachOrdered
.. toArray
.. reduce
.. collect
.. max
.. min
.. count
. 短路操作
.. anyMatch
.. allMatch
.. noneMatch
.. findFirst
.. findAny

== JDBC

=== Statement

* 同一个connection可以创建多个 `Statement`.
* 在处理 `ResultSet` 的结果时也可以创建另外一个 `Statement`.
* `Statement` 不是线程安全的.
* 用完后需要close.
* SQL语句中如果需要使用包含 `?` 符号的函数可以使用 `??` 转义.

=== ResultSet

* 在获取结果集前需要调用 `next()` 方法.
* 使用 `Statement` 获取 `ResultSet` 后, 当前使用中的 `ResultSet` 会直接关闭.
* 用完后需要close.

== NIO

=== Channel

Channel代表程序和某一个文件描述符的连接, 可以是文件(FileChannel), 或者是套接字(DatagramChannel/SocketChannel/ServerSocketChannel).

==== Channel和Stream的区别

* Stream只能是单向的, 分为InputStream和OutputStream, 而Channel可以使双向的.
* Stream的read和write是阻塞的, 而Channel支持非阻塞模式.

=== Buffer

Buffer是一个存放基本类型(除了boolean)数据的容器, 拥有以下属性/方法:

* capacity: Buffer总的容量.
* position: 当前可以写入的位置.
* limit: 能够写入的最后一个位置.
* mark: 记录上一次读写开始的位置(position).
* flip(): 将position赋值给limit, 再将position设置为0, 重置mark, 用于读取Buffer内容.
* rewind(): 将position设置为0, 重置mark, 用于重新读取Buffer内容, 如读取同一个Buffer然后写入多个Channel时.
* mark(): 将position赋值给mark, 记录一下当前position.
* reset(): 重置position为上一次的position.
* clear(): 重置所有变量: position=0, mark=-1, limit=capacity.
* compact(): 将position和limit中间的数据拷贝到Buffer开头, 然后将position指向这段数据的下一个位置.

=== Selector

Selector负责收集通道的事件.

== 多处理器编程

=== 定义

线程A产生一个事件序列 stem:[a_0,a_1,...].
由于线程中往往包含循环, 因此一条程序语句可以产生多次事件.
用 stem:[a_i^j] 表示事件 stem:[a_i] 的第 stem:[j] 次发生. 如果事件a在事件b之前发生, 则称a先于b, 记作 stem:[a->b] .

令 stem:[a_0,a_1]表示事件, 且 stem:[a_0->a_1], stem:[I_A] =interval( stem:[a_0->a_1] )表示 stem:[a_0和a_1] 事件之间的间隔.
如果 stem:[a_1->b_0],则 stem:[I_A->I_B].多个不存在 stem:[->]的关系称为 *并发的*.

* *互斥*: 对于线程A,B, 以及整数j,k, 都有 stem:[CS_A^j->CS_B^i]或者stem:[CS_B^j->CS_A^i].
* *无死锁*: 如果一个线程正在尝试获得一个锁, 那么总会成功地获取到锁, 如果暂时无法获得, 那么一定存在其他线程已经进入临界区.
* *无饥饿*: 每个尝试获得锁的线程最终都能成功.(无饥饿意味着无死锁)

=== 互斥

[source,java]
.Lock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/Lock.java[]
----

==== 双线程实现互斥

[source,java]
.LockOne.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/LockOne.java[]
----

[source,java]
.LockTwo.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/LockTwo.java[]
----

[source,java]
.PetersonLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/PetersonLock.java[]
----

==== 多线程实现互斥

[source,java]
.FilterLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/FilterLock.java[]
----

[source,java]
.BakeryLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/BakeryLock.java[]
----

=== 内存访问

处理器和存储控制器之间通过总线通信, 同一时间只能有一个处理器在总线上广播, 但处理器可以和存储控制器同时广播.
所有的处理器都可以监听.
每一个处理器都有一个cache. 当处理器想从存储器读数据时, 首先检查该内存地址以及值是否已经在cache中. 如果在cache中, 那么处理器可以产生一个cache命中, 立即加载这个值.
如果不在, 则产生一个 `cache miss` , 紧接着在总线上广播这个地址, 其他的处理器监听总线, 如果某个处理器在自己的cache中发现这个地址, 则广播该地址及其值做出响应.
如果所有的处理器都没有发现该地址, 则从内存中加载.

=== 自旋锁

多线程竞争临界区, 如果不能获得锁, 有两种选择:

* 让其继续尝试, 称为 *自旋锁* .
* 挂起自己, 请求操作系统调度另外一个线程, 称为 *阻塞* .

许多操作系统将这两种结合起来使用, 先旋转一个小的时间段再阻塞.

==== TestAndSet

[source,java]
.TASLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/TASLock.java[]
----

.TAS缺点:
* 每个 `getAndSet` 对应总线上一次广播, 该广播会延迟所有的线程, 包括那些没有阻塞锁和准备释放锁的线程.
* `getAndSet` 设置值后会导致所有处理器丢弃 `cache` .

==== TestAndTestAndSet

[source,java]
.TTASLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/TTASLock.java[]
----

.TTAS改进:
* 自旋时只会读取本地的cache值, 不产生总线流量.

==== Backoff TestAndTestAndSet

[source,java]
.Backoff.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/Backoff.java[]
----

[source,java]
.TTASBackoffLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/TTASBackoffLock.java[]
----

.TTASBackoffLock改进:
* 当有其他线程释放锁, 但当前线程没有竞争到锁后会后退一个随机的时间间隔再去争用锁, 减少CPU消耗.

==== 队列锁(数组)

[source,java]
.ArrayLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/ArrayLock.java[]
----

==== 队列锁(CLH)

[source,java]
.CLHLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/CLHLock.java[]
----

==== 队列锁(MCS)

[source,java]
.MCSLock.java
----
include::../basic-knowledge/src/main/java/me/jy/lang/thread/lock/spin/MCSLock.java[]
----

== JVM

.JVM知识点思维导图
plantuml::charts/java/JVM.puml[format=svg,scale=0.5]

=== JVM概述

JVM是一个支持在不同操作系统上执行Java字节码的运行时容器, 拥有内存管理/垃圾回收等功能.
Java字节码无法直接执行, JVM需要将其翻译成机器码.
在HotSpot里, 该翻译过程有两种形式:

* 解释执行: 逐条将字节码翻译成机器码.
* 即时编译执行: 将一个方法中所有的字节码翻译成机器码后再执行.

HotSpot内置多种编译器:

* `C1` 启动块,编译时间短
* `C2` 编译时间比较长,但执行效率高
* `graal`

=== Class文件组成

* magic number
* minor&major versions
* constant pool
* access flags
* this class
* super class
* interfaces
* fields
* methods
* attributes

=== 类加载器

==== 获取类加载器的方法

* 获取某一个类所属的类加载器: `Class::getClassLoader()`
* 获取APP类加载器: `ClassLoader.getSystemClassLoader()`
* 获取当前线程上下文使用的类加载器: `Thread.currentThread().getContextClassLoader()`

==== BootstrapClassLoader

启动类加载器.
本身使用C/C++实现, 没有父加载器.
通过 `sun.misc.Launcher.getBootstrapClassPath().getURLs()` 获取加载类的路径.

==== ExtClassLoader

加载jre/lib/ext子目录下的类库, 父加载器为BootstrapClassLoader.
通过 `System.getProperty("java.ext.dirs")` 获取加载类的路径.

==== AppClassLoader

加载classpath/java.class.path路径下的类库, 是应用程序默认的类加载器.
父加载器为ExtClassLoader.

==== 用户自定义类加载器

.为什么要自定义类加载器?
* 修改类加载的方式.
* 隔离加载类.
* 扩展加载源.
* 防止源码泄露.

.实现自定义类加载器的方式
* 继承 `ClassLoader` 类, 覆盖 `findClass()` 方法.
* 继承 `URLClassLoader` 类.

==== 双亲委派机制

[.lead]
加载某个类的class文件时, 把请求委托给父加载器处理.
如果父加载器无法加载, 则子加载器才会自己去加载.

.优点
* 避免类的重复加载.
* 防止jdk核心类的篡改.

.打破双亲委派机制的案例:
* DriverManager属于JDK下的类, 但从线程上下文取到去加载数据库厂商的JDBC Driver.
* Tomcat使用WebAppClassLoader自己先尝试加载类, 加载不到再去找父类加载.

=== 类加载的过程

==== 加载

. 通过一个类的全限定名获取定义此类的二进制字节流.
. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构.
. 在内存中生成一个代表这个类的 `java.lang.Class` 对象, 作为方法区这个类的各种数据的访问入口.

==== 链接

链接分为 _验证, 准备, 解析_ 三个阶段.

.验证
确保字节流符合当前虚拟机要求, 保证类加载的正确性.
验证文件格式/元数据/字节码/符号引用.

.准备
为静态变量分配零值(null/0).
常量设置初始值.

.解析
解析符号引用为直接引用.

==== 初始化

执行类构造器方法 `clinit()` , 该方法是由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来.

.触发类初始化的条件
* 创建类的实例.
* 访问类的静态变量, 或者对该变量赋值.
* 调用类的静态方法.
* 反射. `Class.forName("FQCN")`
* 加载一个类的子类.
* JVM启动时作为启动入口的类.
* 通过MethodHandler解析的类.

=== JVM内存布局

[plantuml,jvm-memory,svg]
....
@startuml
package "JVM内存布局" {
  [方法区] #Red
  [程序计数器] #Gray
  [本地方法栈] #Gray
  [堆] #Red
  [虚拟机栈] #Gray
}
@enduml
....

红色代表线程共享, 灰色代表线程私有.

==== PC

存储下一条要执行的指令的地址.
如果在执行的是native方法, 则值为undefined.

==== 虚拟机栈

每个线程在创建时都会创建一个虚拟机栈, 栈中的数据以栈帧的格式存在.
在这个线程上执行的每个方法都各自对应一个栈帧.
栈顶的栈帧对应的就是当前正在执行的方法, 如果该方法调用了其他方法, 则创建出一个新的栈帧并入栈.
方法执行完或抛出异常时当前栈帧会出栈.

.栈帧组成
* 局部变量表(方法内部局部变量字节码行号和变量名的映射关系.)
* 操作数栈(在方法执行过程中保存计算结果的临时存储空间. 操作数栈的大小 `max_stack` 在编译时就会确定好, 保存在方法的Code属性中.)
* 动态链接(指向运行时常量池的方法引用.)
* 方法返回地址(存放调用该方法的pc寄存器的值.)
* ...

线程请求分配的栈容量超过JVM允许的最大容量, JVM会抛出 `StackOverflowError` .
如果Java虚拟机栈在尝试扩展的时候申请不到足够的内存, 或者创建新的线程时没有足够的内存去创建对应的虚拟机栈, JVM会抛出 `OutOfMemoryError` .

[source,java]
.StackOverflowError
----
include::../jvm/src/test/java/oom/OOMDemo.java[tag=StackOverflow]
----

[source,java]
.OutOfMemoryError
----
include::../jvm/src/test/java/oom/OOMDemo.java[tag=StackOOM]
----

==== 本地方法栈

管理本地方法的调用.

==== 方法区

==== 堆

=== JDK常用工具

==== jcmd

打印Java进程所涉及的基本类, 线程和VM信息

`jcmd <pid> <command> [args]`

* `jcmd 9914 VM.system_properties` 查看JVM进程properties
* `jcmd 9914 VM.uptime` 查看JVM进程运行时间
* `jcmd 9914 VM.version` 查看JVM版本
* `jcmd 9914 VM.command_line` 查看JVM启动命令
* `jcmd 9914 VM.flags` 查看JVM启动参数
* `jcmd 9914 Thread.print` 查看JVM线程栈信息

==== jps

查看系统运行的所有Java进程的pid

.jps选项:
* `-q` 只打印JVM进程id.
* `-m` 打印main方法执行参数.
* `-l` 打印启动类全限定名或者启动jar包的文件路径.
* `-v` 打印JVM启动参数.

==== jinfo

查看指定Java进程信息

`jinfo [option] <pid>`

* `jinfo -flags 1` 查看pid为1的进程的所有启动参数
* `jinfo -flag UseCompressedOops 9914` 查看指定参数

==== jstack

`jstack <pid>`

查看指定Java进程中每个线程栈信息

==== jstat

`jstat [option] <pid> [interval] [times]`

查看指定进程的内存使用及GC概况. 如: `jstat -gcutil 6451 1000` 每隔1秒输出进程6451的概况

.各列含义
* `S0` 第一个survivor区容量使用率
* `S1` 第二个survivor区容量使用率
* `E` Eden区容量使用率
* `O` Old区容量使用率
* `M` Metaspace区容量使用率
* `YGC` young gc次数
* `YGCT` young gc总耗时
* `FGC` full gc次数
* `FGCT` full gc总耗时
* `GCT` gc总耗时

==== jmap

查看指定进程的堆内存使用情况.

`jmap [option] <pid>`

.jmap选项:
* `-heap` 查看堆内存的配置和使用信息.
* `-histo` 查看各个类实例的数量和占用的内存大小.
* `-dump:format=b;file=xxx.hprof` dump堆内存.

==== javap

查看class字节码文件

`javap <class file>`

* -c: 反编译class
* -p: 显示 `private` 方法和字段
* -v: 显示详细信息
* -s: 显示类型签名
* -l: 输出行号和本地变量表
* -sysinfo: 显示类的系统信息

=== JVM参数

==== 参数分类

JVM主要接受两类标志: boolean类和赋值类参数.

* boolean类:
`-XX:+FLAG_NAME`.
如: `-XX:+UseCompressedOops` 开启64位JVM中的对象引用压缩,`-XX:-UseCompressedOops` 关闭压缩.

* 赋值类: `-XX:+FLAG_NAME=VALUE`.
如 `-XX:AutoBoxCacheMax=20000`.

* 简写类.
如 `-Xms -Xmx -Xmn -Xss`

TIP: 查看所有可选标志: `java -XX:+PrintFlagsFinal -version`

==== 常用启动参数

.GC收集器选择类
* `-XX:+UseSerialGC` 使用Serial+Serial Old组合回收新生代和老年代.
* `-XX:+UseParNewGC` 使用ParNew+Serial Old组合回收新生代和老年代.
* `-XX:+UseConcMarkSweepGC` 使用ParNew+CMS组合回收新生代和老年代, 当出现 _Concurrent Mode Failure_ 后使用Serial Old回收老年代.
* `-XX:+UseParallelGC` 使用Parallel Scavenge+Serial Old组合回收新生代和老年代.
* `-XX:+UseParallelOldGC` 使用Parallel Scavenge+Parallel Old组合回收新生代和老年代.
* `-XX:+UseG1GC` 使用G1回收堆内存.
* `-XX:+UseZGC` 使用ZGC回收堆内存.
* `-XX:+UseShenandoahGC` 使用ShenandoahGC回收堆内存, 只能在OpenJDK12及以上版本中使用.

.Java8及以下GC日志输出类
* `-XX:+PrintGC` 输出GC简要日志.
* `-XX:+PrintGCDetails` 输出gc详细日志.
* `-XX:+PrintHeapAtGC` 输出GC前后堆和方法区容量大小.
* `-XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime` 输出GC与用户线程并发时间以及GC停顿时间.
* `-XX:+PrintAdaptiveSizePolicy` 查看JVM堆各个分代大小自动调节信息.
* `-XX:+PrintTenuringDistribution` 查看GC后剩余对象的年龄分布信息.
* `-Xloggc:<FILENAME> -XX:+UseGCLogfileRotation -XX:NumberOfGCLogfiles=N -XX:GCLogfileSize=N` gc日志写入指定文件并切割.

.Java9及以下GC日志输出类 `-Xlog[:[selector][:[output][:[decorators][:output-options]]]]`
* `-Xlog:gc` 输出GC简要日志.
* `-Xlog:gc*` 输出GC详细日志.
* `-Xlog:gc+heap=debug` 输出GC前后堆和方法区容量大小.
* `-Xlog:safepoint` 输出GC与用户线程并发时间以及GC停顿时间.
* `-Xlog:gc+ergo*=trace` 查看JVM堆各个分代大小自动调节信息.
* `-Xlog:gc+age=trace` 查看GC后剩余对象的年龄分布信息.
* `-Xlog:gc*:file=<file>::filecount=<count>,filesize=<sizekb>` gc日志写入指定文件并切割.

.GC性能类
* `-XX:SurvivorRatio=8` 新生代中 _Eden_ 区和 _Survivor_ 区的比例, 默认为8, 及 8:1:1 .
* `-XX:PretenureSizeThreshold=0` 直接晋升到老年代的对象大小, 大于这个参数的对象将直接在老年代上分配.
* `-XX:MaxTenuringThreshold=15` 晋升到老年代的对象年龄.
每个对象在 _Minor GC_ 后年龄加一, 当年龄超过这个参数后会进入老年代.
* `-XX:+UseAdaptiveSizePolicy` 动态调整堆中各个区域的大小以及老年代的年龄.
* `-XX:ParallelGCThreads=8` 设置并行GC时进行内存回收的线程数.
* `-XX:GCTimeRatio=N` 设置应用运行时间占比: stem:["Throughput"="GCTimeRatio"/(1+"GCTimeRatio")]
* `-XX:MaxGCPauseMillis=N` 设定应用可承受的最大停顿时间.一般设置为200, 如果设置的值过小, 会导致老年代非常小, 从而频繁进行 _Full GC_ .
* `-XX:CMSInitiatingOccupancyFraction=68` 设置CMS收集器在老年代空间被使用多少后触发垃圾回收, 默认为68%.
* `-XX:+UseCMSCompactAtFullCollection` 设置CMS在 _Full GC_ 后是否进行内存碎片整理. [Java9后废弃]
* `-XX:CMSFullGCsBeforeCompaction=0` 设置CMS在多少次 _Full GC_ 后进行内存碎片整理. [Java9后废弃]
* `-XX:G1HeapRegionSize=0` 设置G1 Region大小.
* `-XX:G1NewSizePercent=5` 设置G1新生代最小值, 默认为5%.
* `-XX:G1MaxNewSizePercent=60` 设置G1新生代最大值, 默认为60%.
* `-XX:InitiatingHeapOccupancyPercent` 设置触发标记周期的堆(old+humongous)占用阈值, 默认为45%.

=== 内存分配策略

==== 内存分配方式

* 指针碰撞: 所有被使用的内存放一边, 空闲的内存放一边, 维护一个指针标识两部分内存的分界线, 使用标记-整理的垃圾回收器会使用指针碰撞的分配方式.
* 空闲列表: 虚拟机维护一个列表, 记录哪些内存块是可用的, 哪些是不可用的, 使用标记-清除的垃圾回收器会使用空闲列表的分配方式.

==== 对象优先在Eden区分配

大多数情况下, 对象在新生代Eden区中分配.
当Eden区没有足够空间进行分配时, 虚拟机将发起一次 _Minor GC_ .

==== 大对象直接进入老年代

需要大量连续内存空间的Java对象(如数组), 直接在老年代分配.
虚拟机提供了 `-XX:PretenureSizeThreshold` 参数指定大于该参数值的对象直接在老年代分配.

==== 长期存活的对象进入老年代

对象如果在 _Minor GC_ 后仍然存活, 并能被Survivor区容纳, 则移动到Survivor区, 年龄加1. 年龄超过 `MaxTenuringThreshold` 参数后, 下次 _Minor GC_ 时会进入老年代.

==== 老年代空间分配担保

_Minor GC_ 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于等于新生代所有对象总空间或者大于等于历史晋升的平均大小, 如果大于则进行 _Minor GC_ , 否则将直接进行 _Full FC_ .

=== 垃圾收集算法

==== 复制

将内存按容量划分为大小相等的两块, 每次只用其中的一块.
当某一块的内存用完了, 就将还存活的的对象复制到另外一块上, 然后再把已使用过的内存空间一次清理掉.

.优点
* 为对象分配内存时不需要考虑内存碎片的问题.

.缺点
* 可用内存只有一半.
* 如果对象的存活率高, 则拷贝对象的操作开销比较大.

.使用场景
* Serial/ParNew收集器使用复制算法收集新生代.

==== 标记整理

让所有存活的对象向内存空间一端移动, 然后直接清理掉边界以外的内存.

.优点
* 没有内存碎片

.缺点
* 移动对象的开销大.

.使用场景
* Serial Old/Parallel Scavenge使用标记-整理算法收集老年代.

==== 标记清除

首先标记出所有需要回收的对象, 在标记完成后统一回收所有被标记的对象.

.优点
* 相对于复制算法节省了内存空间.

.缺点
* 执行效率不稳定, 如果内存中大量对象需要被回收, 则必须进行大量标记和清除的动作.
* 导致内存碎片化.

.使用场景
* CMS使用标记清除算法回收老年代.

=== GC分类

* Minor GC/Young GC: 新生代的收集.
* Major GC/Old GC: 老年代的收集.(CMS)
* Mixed GC: 收集整个新生代和部分老年代的过程.(G1)
* Full GC: 整个Java堆和方法区的收集.

=== GC Root

* 虚拟机栈和本地方法栈中本地变量表引用的对象.
* 方法区中静态属性引用的对象.
* 方法区中常量引用的对象.
* 虚拟机内部的类引用的对象, 比如JDK官方的类Class对象或者类加载器.
* 被同步锁持有的对象.

=== 垃圾收集器

[.lead]
垃圾收集分两步: 在为对象分配内存时遇到内存不足, 查找不再使用的对象, 然后释放这些对象所在的内存.

由于对象的生存时间不同, 所有的垃圾收集器都采用分代收集的方式.
堆内存被划分为 *新生代* (Young Generation)和 *老年代* (Old Generation或Tenured Generation), 默认空间占比 1:2. 新生代又被分为一个Eden区和两个Survivor区.
默认空间占比 8:1:1.

* 对象首先在新生代Eden区分配, *Eden区填满时* , 垃圾收集器会暂停所有应用线程回收新生代(垃圾收集时所有应用线程停止运行所产生的停顿称为 **STW** (stop-the-world)).此时不再使用的对象会被回收, 仍在使用的对象会移动到Survivor区或老年代, 这一过程称为 *Minor GC* . 由于所有的存活对象都被移走, 此时相当于在新生代做了一次整理.
* 单独回收老年代的过程称为 *Major GC* . (CMS)
* 回收新生代和一部分老年代的过程称为 *Mixed GC* .(G1)
* 对象不断移动到老年代, 等到 *老年代空间占满* , JVM会回收整个堆, 这一过程称为 *Full GC* .

==== Serial

[.lead]
Serial垃圾收集器使用 *单线程* 回收内存, 垃圾回收时会暂停所有的用户线程.
使用 `-XX:+UseSerialGC` 启用Serial垃圾收集器.

* 新生代 `Serial` 使用复制算法, GC时会暂停所有用户线程.
* 老年代 `Serial Old` 使用标记-整理算法, GC时暂停所有用户线程.

[source,text]
----
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xmx500m -XX:+UseSerialGC GCLogAnalysis
2020-10-27T20:27:43.434-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.434-0800: [DefNew: 69870K->8703K(78656K), 0.0146897 secs] 69870K->23463K(253440K), 0.0147228 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] <1>
2020-10-27T20:27:43.475-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.475-0800: [DefNew: 78655K->8704K(78656K), 0.0219163 secs] 93415K->43153K(253440K), 0.0219731 secs] [Times: user=0.01 sys=0.01, real=0.02 secs]
2020-10-27T20:27:43.518-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.518-0800: [DefNew: 78656K->8704K(78656K), 0.0268356 secs] 113105K->68112K(253440K), 0.0268698 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
2020-10-27T20:27:43.573-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.573-0800: [DefNew: 78656K->8703K(78656K), 0.0283694 secs] 138064K->86737K(253440K), 0.0284128 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
2020-10-27T20:27:43.633-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.633-0800: [DefNew: 78655K->8704K(78656K), 0.0204895 secs] 156689K->110372K(253440K), 0.0205465 secs] [Times: user=0.01 sys=0.01, real=0.02 secs]
2020-10-27T20:27:43.675-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.675-0800: [DefNew: 78656K->8698K(78656K), 0.0295495 secs] 180324K->135983K(253440K), 0.0295976 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
2020-10-27T20:27:43.719-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.719-0800: [DefNew: 78650K->8704K(78656K), 0.0269409 secs] 205935K->161503K(253440K), 0.0269808 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
2020-10-27T20:27:43.758-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.758-0800: [DefNew: 78553K->8703K(78656K), 0.0247593 secs]2020-10-27T20:27:43.783-0800: [Tenured: 174929K->161954K(174976K), 0.0382564 secs] 231353K->161954K(253632K), [Metaspace: 5478K->5478K(1056768K)], 0.0632989 secs] [Times: user=0.05 sys=0.01, real=0.07 secs] <2>
2020-10-27T20:27:43.858-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.858-0800: [DefNew: 108096K->13439K(121536K), 0.0261365 secs] 270050K->199412K(391464K), 0.0261749 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
2020-10-27T20:27:43.910-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.910-0800: [DefNew: 121535K->13430K(121536K), 0.0407543 secs] 307508K->233687K(391464K), 0.0407952 secs] [Times: user=0.05 sys=0.03, real=0.04 secs]
2020-10-27T20:27:43.979-0800: [GC (Allocation Failure) 2020-10-27T20:27:43.979-0800: [DefNew: 121526K->13439K(121536K), 0.0282363 secs] 341783K->266291K(391464K), 0.0282747 secs] [Times: user=0.01 sys=0.01, real=0.03 secs]
2020-10-27T20:27:44.033-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.033-0800: [DefNew: 121417K->13432K(121536K), 0.0318451 secs]2020-10-27T20:27:44.065-0800: [Tenured: 290446K->241497K(290448K), 0.0549298 secs] 374268K->241497K(411984K), [Metaspace: 5478K->5478K(1056768K)], 0.0869765 secs] [Times: user=0.07 sys=0.02, real=0.09 secs]
2020-10-27T20:27:44.137-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.137-0800: [DefNew: 136419K->17022K(153600K), 0.0244343 secs] 377916K->287817K(494976K), 0.0244742 secs] [Times: user=0.01 sys=0.01, real=0.03 secs]
2020-10-27T20:27:44.188-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.188-0800: [DefNew: 153167K->17023K(153600K), 0.0434442 secs] 423962K->328060K(494976K), 0.0435019 secs] [Times: user=0.02 sys=0.02, real=0.05 secs]
2020-10-27T20:27:44.249-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.249-0800: [DefNew: 153599K->153599K(153600K), 0.0000215 secs]2020-10-27T20:27:44.249-0800: [Tenured: 311036K->293415K(341376K), 0.0753151 secs] 464636K->293415K(494976K), [Metaspace: 5478K->5478K(1056768K)], 0.0754695 secs] [Times: user=0.07 sys=0.00, real=0.08 secs]
2020-10-27T20:27:44.351-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.351-0800: [DefNew: 136576K->17022K(153600K), 0.0170228 secs] 429991K->341321K(494976K), 0.0170677 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
2020-10-27T20:27:44.385-0800: [GC (Allocation Failure) 2020-10-27T20:27:44.385-0800: [DefNew: 153598K->153598K(153600K), 0.0000162 secs]2020-10-27T20:27:44.385-0800: [Tenured: 324298K->300756K(341376K), 0.0832796 secs] 477897K->300756K(494976K), [Metaspace: 5478K->5478K(1056768K)], 0.0833456 secs] [Times: user=0.08 sys=0.00, real=0.08 secs]
Heap
 def new generation   total 153600K, used 5917K [0x00000007a0c00000, 0x00000007ab2a0000, 0x00000007ab2a0000)
  eden space 136576K,   4% used [0x00000007a0c00000, 0x00000007a11c75b0, 0x00000007a9160000)
  from space 17024K,   0% used [0x00000007aa200000, 0x00000007aa200000, 0x00000007ab2a0000)
  to   space 17024K,   0% used [0x00000007a9160000, 0x00000007a9160000, 0x00000007aa200000)
 tenured generation   total 341376K, used 300756K [0x00000007ab2a0000, 0x00000007c0000000, 0x00000007c0000000)
   the space 341376K,  88% used [0x00000007ab2a0000, 0x00000007bd8553b0, 0x00000007bd855400, 0x00000007c0000000)
 Metaspace       used 5492K, capacity 5958K, committed 6016K, reserved 1056768K
  class space    used 595K, capacity 626K, committed 640K, reserved 1048576K
----
<1> 本次为YoungGC, Young区总大小为78656K, 整个堆总大小为253440K, GC后Young区使用量从69870K降到了8703K, 整个堆使用量从69870K降到了23463K.
<2> 本次为FullGC, Young区总大小为78656K, Old区总大小为174976K, 整个堆总大小为253632K, GC后Young区使用量从78553K降到了8703K, Old区使用量从174929K降到了161954K, 整个堆使用量从231353K降到了161954K.

==== Parallel

TIP: JDK8默认收集器.

[.lead]
Parallel垃圾收集器使用 *多线程* 并行回收内存, 垃圾回收时会暂停所有的用户线程.
使用 `-XX:+UseParallelGC` 启用Parallel垃圾收集器.

* 新生代 `Parallel Scavenge` 使用复制算法, GC时暂停所有用户线程.
* 老年代 `Parallel Old` 使用标记-整理算法, GC时暂停所有用户线程.

.Parallel收集器参数
* `-XX:MaxGCPauseMills` 收集器将尽力保证内存回收花费的时间不包括这个设定的值.
* `-XX:GCTimeRatio` 垃圾收集时间占总时间的占比. 默认99.
* `-XX:+UseAdaptiveSizePolicy` JVM根据当前系统的运行信息自动调节 `-Xmn/-XX:SurvivorRatio/-XX:PretenureSizeThreshold`

[source,text]
----
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xmx500m -XX:+UseParallelGC GCLogAnalysis
2020-10-27T20:31:42.234-0800: [GC (Allocation Failure) [PSYoungGen: 65536K->10732K(76288K)] 65536K->27190K(251392K), 0.0121700 secs] [Times: user=0.01 sys=0.05, real=0.01 secs] <1>
2020-10-27T20:31:42.274-0800: [GC (Allocation Failure) [PSYoungGen: 76208K->10749K(141824K)] 92666K->51153K(316928K), 0.0158102 secs] [Times: user=0.02 sys=0.07, real=0.02 secs]
2020-10-27T20:31:42.359-0800: [GC (Allocation Failure) [PSYoungGen: 141821K->10751K(141824K)] 182225K->92844K(316928K), 0.0271800 secs] [Times: user=0.04 sys=0.11, real=0.03 secs]
2020-10-27T20:31:42.425-0800: [GC (Allocation Failure) [PSYoungGen: 141823K->10751K(159744K)] 223916K->140207K(334848K), 0.0303295 secs] [Times: user=0.04 sys=0.13, real=0.03 secs]
2020-10-27T20:31:42.455-0800: [Full GC (Ergonomics) [PSYoungGen: 10751K->0K(159744K)] [ParOldGen: 129455K->126304K(263680K)] 140207K->126304K(423424K), [Metaspace: 5486K->5486K(1056768K)], 0.0292847 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] <2>
2020-10-27T20:31:42.527-0800: [GC (Allocation Failure) [PSYoungGen: 148992K->10751K(159744K)] 275296K->177754K(423424K), 0.0274459 secs] [Times: user=0.05 sys=0.10, real=0.03 secs]
2020-10-27T20:31:42.591-0800: [GC (Allocation Failure) [PSYoungGen: 159743K->10743K(67584K)] 326746K->226687K(331264K), 0.0304457 secs] [Times: user=0.05 sys=0.11, real=0.03 secs]
2020-10-27T20:31:42.621-0800: [Full GC (Ergonomics) [PSYoungGen: 10743K->0K(67584K)] [ParOldGen: 215944K->188313K(341504K)] 226687K->188313K(409088K), [Metaspace: 5486K->5486K(1056768K)], 0.0271394 secs] [Times: user=0.12 sys=0.00, real=0.02 secs]
2020-10-27T20:31:42.669-0800: [GC (Allocation Failure) [PSYoungGen: 56258K->16332K(113664K)] 244572K->204646K(455168K), 0.0024383 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
2020-10-27T20:31:42.687-0800: [GC (Allocation Failure) [PSYoungGen: 73164K->32564K(113664K)] 261478K->220878K(455168K), 0.0075769 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]
2020-10-27T20:31:42.709-0800: [GC (Allocation Failure) [PSYoungGen: 88659K->47677K(113664K)] 276972K->235991K(455168K), 0.0078832 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
2020-10-27T20:31:42.736-0800: [GC (Allocation Failure) [PSYoungGen: 104509K->36972K(113664K)] 292823K->254875K(455168K), 0.0100647 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]
2020-10-27T20:31:42.772-0800: [GC (Allocation Failure) [PSYoungGen: 93415K->18147K(113664K)] 311317K->271321K(455168K), 0.0249421 secs] [Times: user=0.03 sys=0.09, real=0.02 secs]
2020-10-27T20:31:42.806-0800: [GC (Allocation Failure) [PSYoungGen: 74947K->19445K(113664K)] 328122K->289146K(455168K), 0.0093222 secs] [Times: user=0.02 sys=0.02, real=0.01 secs]
2020-10-27T20:31:42.831-0800: [GC (Allocation Failure) [PSYoungGen: 76277K->17627K(113664K)] 345978K->305371K(455168K), 0.0089946 secs] [Times: user=0.02 sys=0.03, real=0.01 secs]
2020-10-27T20:31:42.854-0800: [GC (Allocation Failure) [PSYoungGen: 74459K->16959K(113664K)] 362203K->321770K(455168K), 0.0116318 secs] [Times: user=0.03 sys=0.04, real=0.01 secs]
2020-10-27T20:31:42.866-0800: [Full GC (Ergonomics) [PSYoungGen: 16959K->0K(113664K)] [ParOldGen: 304811K->241616K(341504K)] 321770K->241616K(455168K), [Metaspace: 5486K->5486K(1056768K)], 0.0484392 secs] [Times: user=0.23 sys=0.01, real=0.05 secs]
2020-10-27T20:31:42.930-0800: [GC (Allocation Failure) [PSYoungGen: 56669K->22742K(113664K)] 298286K->264359K(455168K), 0.0036387 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:31:42.943-0800: [GC (Allocation Failure) [PSYoungGen: 79574K->18280K(113664K)] 321191K->281473K(455168K), 0.0054439 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]
2020-10-27T20:31:42.967-0800: [GC (Allocation Failure) [PSYoungGen: 75074K->20044K(113664K)] 338267K->300845K(455168K), 0.0054350 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]
2020-10-27T20:31:42.989-0800: [GC (Allocation Failure) [PSYoungGen: 76850K->23313K(113664K)] 357652K->322762K(455168K), 0.0099082 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
2020-10-27T20:31:43.008-0800: [GC (Allocation Failure) [PSYoungGen: 80105K->16903K(113664K)] 379553K->338875K(455168K), 0.0191813 secs] [Times: user=0.05 sys=0.06, real=0.02 secs]
2020-10-27T20:31:43.027-0800: [Full GC (Ergonomics) [PSYoungGen: 16903K->0K(113664K)] [ParOldGen: 321971K->272257K(341504K)] 338875K->272257K(455168K), [Metaspace: 5486K->5486K(1056768K)], 0.0505424 secs] [Times: user=0.24 sys=0.00, real=0.05 secs]
2020-10-27T20:31:43.096-0800: [GC (Allocation Failure) [PSYoungGen: 56243K->22017K(113664K)] 328500K->294275K(455168K), 0.0045945 secs] [Times: user=0.02 sys=0.01, real=0.01 secs]
2020-10-27T20:31:43.110-0800: [GC (Allocation Failure) [PSYoungGen: 78849K->18143K(113664K)] 351107K->311726K(455168K), 0.0061414 secs] [Times: user=0.03 sys=0.00, real=0.00 secs]
2020-10-27T20:31:43.130-0800: [GC (Allocation Failure) [PSYoungGen: 74971K->16293K(113664K)] 368555K->325547K(455168K), 0.0059918 secs] [Times: user=0.03 sys=0.00, real=0.00 secs]
2020-10-27T20:31:43.136-0800: [Full GC (Ergonomics) [PSYoungGen: 16293K->0K(113664K)] [ParOldGen: 309254K->287559K(341504K)] 325547K->287559K(455168K), [Metaspace: 5486K->5486K(1056768K)], 0.0510250 secs] [Times: user=0.24 sys=0.00, real=0.05 secs]
Heap
 PSYoungGen      total 113664K, used 28277K [0x00000007b5980000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 56832K, 49% used [0x00000007b5980000,0x00000007b751d4e0,0x00000007b9100000)
  from space 56832K, 0% used [0x00000007bc880000,0x00000007bc880000,0x00000007c0000000)
  to   space 56832K, 0% used [0x00000007b9100000,0x00000007b9100000,0x00000007bc880000)
 ParOldGen       total 341504K, used 287559K [0x00000007a0c00000, 0x00000007b5980000, 0x00000007b5980000)
  object space 341504K, 84% used [0x00000007a0c00000,0x00000007b24d1cb0,0x00000007b5980000)
 Metaspace       used 5499K, capacity 5958K, committed 6016K, reserved 1056768K
  class space    used 595K, capacity 626K, committed 640K, reserved 1048576K
----
<1> 本次为YoungGC, Young区总大小为76288K, 整个堆总大小为251392K, GC后Young区使用量从65536K降到了10732K, 整个堆使用量从65536K降到了27190K.
<2> 本次为FullGC, Young区总大小为159744K, Old区总大小为263680K, 整个堆总大小为423424K, GC后Young区使用量从10751K降到了0K, Old区使用量从129455K降到了126304K, 整个堆使用量从140207K降到了126304K.

==== ParNew

[.lead]
Serial垃圾收集器使用 *多线程* 回收 *新生代内存* (线程数等于CPU数), 垃圾回收时会暂停所有的应用线程.
使用 `-XX:+UseParNewGC` 启用ParNew垃圾收集器.
通常与CMS搭配使用.

* 新生代 `ParNew` 使用复制算法, GC时会暂停所有用户线程.

==== CMS

WARNING: JDK14被移除.

CMS使用多线程并发回收老年代内存, 使用 `-XX:+UseConcMarkSweepGC` 启用CMS收集器.

.CMS回收流程
. 初始标记: 单线程标记一下 `GC Roots` 对象.
. 并发标记: 从 `GC Roots` 对象开始遍历整个对象图.
. 重新标记: 修正并发标记期间, 因用户程序继续运作而导致标记变动的那部分对象的标记记录.
. 并发清除: 清除那些被标记为死亡的对象.
阶段1和阶段3会暂停所有用户线程, 阶段2和阶段4GC线程可以和用户线程并发执行.

CMS回收并发线程数默认是 stem:[("nCPU"+3)/4] .

.CMS参数
* `-XX:CMSInitiatingOccupancyFraction` 老年代占用超过这个阈值后会触发CMS回收内存.
* `-XX:+UseCMSCompactAtFullCollection` 在Full GC时开启内存碎片的合并.
* `-XX:CMSFullGCsBeforeCompaction` 在执行指定次数不整理空间的Full FC后, 在下一次Full GC前整理内存碎片.
* `-XX:+CMSScavengeBeforeRemark` 在CMS重新标记阶段前触发 `Young GC` .

.CMS退化成SerialOld收集器触发FullGC的两个诱因
* YoungGC导致Young区对象晋升到Old区, 但是Old区没有足够容量收纳晋升过来的对象, 此时触发FullGC, 在GC日志中标识为 `promotion failed` .
** 解决办法: 增大Young区大小.
* CMS并发标记阶段应用线程会产生一部分新的可回收对象( _浮动垃圾_ ), 且分配新的对象内存的时候可能因为内存不足触发FullGC, 在GC日志中标识为 `concurrent mode failure` .
** 解决办法: 让Old区提前回收(-XX:CMSInitiatingOccupancyFraction), 或者每次CMS GC后整理下内存(-XX:+UseCMSCompactAtFullCollection).

[source,text]
----
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xmx500m -XX:+UseConcMarkSweepGC GCLogAnalysis
2020-10-27T20:39:17.104-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.104-0800: [ParNew: 69952K->8698K(78656K), 0.0093642 secs] 69952K->22083K(253440K), 0.0094129 secs] [Times: user=0.02 sys=0.04, real=0.01 secs] <1>
2020-10-27T20:39:17.141-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.141-0800: [ParNew: 78650K->8698K(78656K), 0.0087938 secs] 92035K->39298K(253440K), 0.0088282 secs] [Times: user=0.02 sys=0.03, real=0.01 secs]
2020-10-27T20:39:17.174-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.174-0800: [ParNew: 78650K->8703K(78656K), 0.0225999 secs] 109250K->60847K(253440K), 0.0227016 secs] [Times: user=0.12 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.218-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.218-0800: [ParNew: 78324K->8704K(78656K), 0.0192211 secs] 130467K->82592K(253440K), 0.0192581 secs] [Times: user=0.11 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.267-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.267-0800: [ParNew: 78656K->8702K(78656K), 0.0162077 secs] 152544K->107316K(253440K), 0.0162478 secs] [Times: user=0.10 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.283-0800: [GC (CMS Initial Mark) [1 CMS-initial-mark: 98614K(174784K)] 108733K(253440K), 0.0001820 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <2>
2020-10-27T20:39:17.283-0800: [CMS-concurrent-mark-start] <3>
2020-10-27T20:39:17.285-0800: [CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.285-0800: [CMS-concurrent-preclean-start] <4>
2020-10-27T20:39:17.286-0800: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.286-0800: [CMS-concurrent-abortable-preclean-start] <5>
2020-10-27T20:39:17.304-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.304-0800: [ParNew: 78654K->8700K(78656K), 0.0146260 secs] 177268K->129456K(253440K), 0.0146893 secs] [Times: user=0.09 sys=0.01, real=0.01 secs]
2020-10-27T20:39:17.340-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.340-0800: [ParNew: 78652K->8698K(78656K), 0.0170268 secs] 199408K->150863K(253440K), 0.0170998 secs] [Times: user=0.11 sys=0.00, real=0.01 secs]
2020-10-27T20:39:17.372-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.372-0800: [ParNew: 78397K->8702K(78656K), 0.0147147 secs] 220562K->172577K(253440K), 0.0147697 secs] [Times: user=0.09 sys=0.00, real=0.01 secs]
2020-10-27T20:39:17.407-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.407-0800: [ParNew: 78368K->8702K(78656K), 0.0148902 secs] 242243K->195716K(266244K), 0.0149562 secs] [Times: user=0.09 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.443-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.443-0800: [ParNew: 78654K->8703K(78656K), 0.0261878 secs] 265668K->223486K(294104K), 0.0262856 secs] [Times: user=0.15 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.490-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.491-0800: [ParNew: 78655K->8703K(78656K), 0.0269818 secs] 293438K->244642K(315344K), 0.0271319 secs] [Times: user=0.13 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.530-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.530-0800: [ParNew: 78467K->8700K(78656K), 0.0222884 secs] 314407K->269319K(339980K), 0.0224062 secs] [Times: user=0.14 sys=0.02, real=0.02 secs]
2020-10-27T20:39:17.572-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.572-0800: [ParNew: 78652K->8697K(78656K), 0.0280387 secs] 339271K->293670K(364248K), 0.0281057 secs] [Times: user=0.17 sys=0.02, real=0.03 secs]
2020-10-27T20:39:17.611-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.611-0800: [ParNew: 78338K->8702K(78656K), 0.0207492 secs] 363311K->316144K(386844K), 0.0208035 secs] [Times: user=0.12 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.661-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.661-0800: [ParNew: 78654K->8703K(78656K), 0.0168668 secs] 386096K->337852K(408460K), 0.0169848 secs] [Times: user=0.11 sys=0.00, real=0.01 secs]
2020-10-27T20:39:17.679-0800: [CMS-concurrent-abortable-preclean: 0.016/0.393 secs] [Times: user=1.55 sys=0.15, real=0.39 secs]
2020-10-27T20:39:17.679-0800: [GC (CMS Final Remark) [YG occupancy: 17167 K (78656 K)]2020-10-27T20:39:17.679-0800: [Rescan (parallel) , 0.0009628 secs]2020-10-27T20:39:17.680-0800: [weak refs processing, 0.0000274 secs]2020-10-27T20:39:17.680-0800: [class unloading, 0.0008790 secs]2020-10-27T20:39:17.681-0800: [scrub symbol table, 0.0008922 secs]2020-10-27T20:39:17.682-0800: [scrub string table, 0.0002329 secs][1 CMS-remark: 329149K(329804K)] 346317K(408460K), 0.0031208 secs] [Times: user=0.01 sys=0.01, real=0.01 secs] <6>
2020-10-27T20:39:17.682-0800: [CMS-concurrent-sweep-start] <7>
2020-10-27T20:39:17.683-0800: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.683-0800: [CMS-concurrent-reset-start] <8>
2020-10-27T20:39:17.684-0800: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.700-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.701-0800: [ParNew: 78302K->78302K(78656K), 0.0000177 secs]2020-10-27T20:39:17.701-0800: [CMS: 318914K->241056K(341376K), 0.0705879 secs] 397217K->241056K(420032K), [Metaspace: 5484K->5484K(1056768K)], 0.0708164 secs] [Times: user=0.09 sys=0.00, real=0.07 secs]
2020-10-27T20:39:17.772-0800: [GC (CMS Initial Mark) [1 CMS-initial-mark: 241056K(341376K)] 241603K(494976K), 0.0002567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.772-0800: [CMS-concurrent-mark-start]
2020-10-27T20:39:17.774-0800: [CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.774-0800: [CMS-concurrent-preclean-start]
2020-10-27T20:39:17.775-0800: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.775-0800: [CMS-concurrent-abortable-preclean-start]
2020-10-27T20:39:17.827-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.827-0800: [ParNew: 136576K->17017K(153600K), 0.0153041 secs] 377632K->289227K(494976K), 0.0153775 secs] [Times: user=0.10 sys=0.01, real=0.02 secs]
2020-10-27T20:39:17.871-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.871-0800: [ParNew: 153593K->17022K(153600K), 0.0170277 secs] 425803K->336041K(494976K), 0.0170661 secs] [Times: user=0.12 sys=0.01, real=0.01 secs]
2020-10-27T20:39:17.891-0800: [CMS-concurrent-abortable-preclean: 0.005/0.116 secs] [Times: user=0.36 sys=0.05, real=0.12 secs]
2020-10-27T20:39:17.891-0800: [GC (CMS Final Remark) [YG occupancy: 22623 K (153600 K)]2020-10-27T20:39:17.891-0800: [Rescan (parallel) , 0.0016173 secs]2020-10-27T20:39:17.893-0800: [weak refs processing, 0.0000399 secs]2020-10-27T20:39:17.893-0800: [class unloading, 0.0023604 secs]2020-10-27T20:39:17.896-0800: [scrub symbol table, 0.0010799 secs]2020-10-27T20:39:17.897-0800: [scrub string table, 0.0002871 secs][1 CMS-remark: 319019K(341376K)] 341642K(494976K), 0.0056143 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.897-0800: [CMS-concurrent-sweep-start]
2020-10-27T20:39:17.899-0800: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.899-0800: [CMS-concurrent-reset-start]
2020-10-27T20:39:17.899-0800: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.920-0800: [GC (Allocation Failure) 2020-10-27T20:39:17.920-0800: [ParNew: 153598K->153598K(153600K), 0.0000383 secs]2020-10-27T20:39:17.920-0800: [CMS: 318202K->283658K(341376K), 0.0618453 secs] 471801K->283658K(494976K), [Metaspace: 5484K->5484K(1056768K)], 0.0619482 secs] [Times: user=0.06 sys=0.00, real=0.06 secs]
2020-10-27T20:39:17.982-0800: [GC (CMS Initial Mark) [1 CMS-initial-mark: 283658K(341376K)] 286702K(494976K), 0.0002134 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.982-0800: [CMS-concurrent-mark-start]
2020-10-27T20:39:17.984-0800: [CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.984-0800: [CMS-concurrent-preclean-start]
2020-10-27T20:39:17.985-0800: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:17.985-0800: [CMS-concurrent-abortable-preclean-start]
2020-10-27T20:39:18.007-0800: [GC (Allocation Failure) 2020-10-27T20:39:18.007-0800: [ParNew: 136576K->17023K(153600K), 0.0083199 secs] 420234K->331289K(494976K), 0.0083692 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
2020-10-27T20:39:18.017-0800: [CMS-concurrent-abortable-preclean: 0.002/0.032 secs] [Times: user=0.08 sys=0.00, real=0.03 secs]
2020-10-27T20:39:18.017-0800: [GC (CMS Final Remark) [YG occupancy: 29614 K (153600 K)]2020-10-27T20:39:18.017-0800: [Rescan (parallel) , 0.0004149 secs]2020-10-27T20:39:18.017-0800: [weak refs processing, 0.0000117 secs]2020-10-27T20:39:18.017-0800: [class unloading, 0.0009162 secs]2020-10-27T20:39:18.018-0800: [scrub symbol table, 0.0007536 secs]2020-10-27T20:39:18.019-0800: [scrub string table, 0.0001732 secs][1 CMS-remark: 314265K(341376K)] 343879K(494976K), 0.0023383 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:18.019-0800: [CMS-concurrent-sweep-start]
2020-10-27T20:39:18.020-0800: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
2020-10-27T20:39:18.020-0800: [CMS-concurrent-reset-start]
2020-10-27T20:39:18.020-0800: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:18.040-0800: [GC (Allocation Failure) 2020-10-27T20:39:18.040-0800: [ParNew: 153599K->153599K(153600K), 0.0000214 secs]2020-10-27T20:39:18.040-0800: [CMS: 314265K->309716K(341376K), 0.0750800 secs] 467865K->309716K(494976K), [Metaspace: 5484K->5484K(1056768K)], 0.0751629 secs] [Times: user=0.08 sys=0.00, real=0.07 secs]
2020-10-27T20:39:18.116-0800: [GC (CMS Initial Mark) [1 CMS-initial-mark: 309716K(341376K)] 312690K(494976K), 0.0002100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2020-10-27T20:39:18.116-0800: [CMS-concurrent-mark-start]
 ִcounter:6777
Heap
 par new generation   total 153600K, used 5705K [0x00000007a0c00000, 0x00000007ab2a0000, 0x00000007ab2a0000)
  eden space 136576K,   4% used [0x00000007a0c00000, 0x00000007a1192510, 0x00000007a9160000)
  from space 17024K,   0% used [0x00000007aa200000, 0x00000007aa200000, 0x00000007ab2a0000)
  to   space 17024K,   0% used [0x00000007a9160000, 0x00000007a9160000, 0x00000007aa200000)
 concurrent mark-sweep generation total 341376K, used 309716K [0x00000007ab2a0000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 5499K, capacity 5958K, committed 6016K, reserved 1056768K
  class space    used 595K, capacity 626K, committed 640K, reserved 1048576K
----
<1> 本次为YoungGC, Young区总大小为78656K, 整个堆总大小为253440K, GC后Young区使用量从69952K降到了8698K, 整个堆使用量从69952K降到了22083K.
<2> CMS开始MinorGC, 此时Old区占用98614K/174784K, 整个堆占用108733K/253440K, 本次为开始标记阶段, 会暂停所有用户线程.
<3> 并发标记阶段, 与用户线程并发执行.
<4> 预清理阶段, 与用户线程并发执行.
<5> 可中断预清理阶段, 等待上一次YoungGC结束一段时间后再准备开始下一个阶段(为了防止YoungGC和最终标记连续暂停用户线程两次).
<6> 最终标记阶段, 此时暂停用户线程0.01秒.
<7> 并发清除阶段, 开始回收老年代, 此时GC线程与用户线程并发执行.
<8> 并发重置阶段.

==== G1

TIP: JDK9默认收集器

G1将堆划分为多个大小相等的独立区域, 每个区域可以根据需要扮演Eden/Survivor/Old/Humongous空间.
使用 `-XX:+UseG1GC` 启动G1收集器.

.G1回收流程
. 初始标记: 单线程标记 `GC Roots` 对象.
. 并发标记: 从 `GC Roots` 对象开始遍历整个对象图.
. 最终标记: 修正并发标记期间, 因用户程序继续运作而导致标记变动的那部分对象的标记记录.
. 筛选回收: 将回收的Region存活下来的对象复制到空的Region中再清空原来的Region.

==== ZGC

TIP: JDK11新增的收集器

使用 `-XX:+UseZGC` 启动ZGC收集器.

.ZGC回收流程
. 并发标记
. 并发预备重分配
. 并发重分配
. 并发重映射

=== GC调优

==== 选择恰当的垃圾收集器

* 数据分析/科学计算类应用, 关注吞吐量. `ParallelGC`
* 事务型应用, 关注低延迟. `CMS/G1/ZGC`
* 客户端/嵌入式设备应用, 关注内存占用.

==== 永远不要把堆内存的大小设置的比机器物理内存大

 Full GC时JVM会访问整个堆的内容, 内存交换会拖慢GC的速度. 使用-Xms和-Xmx分别设置堆内存的最小值和最大值.
 默认64位JVM堆内存初始值为取512MB和物理内存大小1/64二者中的最小值, 最大值取32G和物理内存大小1/4二者中的最小值.

==== 调整新生代与老年代的大小

.新生代大小设置参数, 后者优先级更高
** -XX:NewRatio 设置新生代与老年代的比例, 默认值为2. 默认情况下新生代大小初始值等于 `初始堆大小/(1+NewRatio)`
** -XX:NewSize 设置新生代大小的初始值
** -XX:MaxNewSize 设置新生代大小的最大值
** -Xmn 同时设置新生代的初始值和最大值

=== 调试JDK源码

. 下载openjdk源码: `git clone https://github.com/openjdk/jdk.git`
. 设置当前使用的jdk(BootJDK)版本为最新的发布版本.
. `bash configure --enable-debug`
. `make images`
. 等待编译结束, build目录下会生成jdk目录.
. CLion导入项目, 选择 `New CMake project from existing sources` .
