= Java
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:hardbreaks:
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

== 数据类型

* 基本数据类型
** byte stem:[-2^7 ~ 2*7-1]
** short stem:[-2^15~2^15-1]
** int stem:[-2^31~2^31-1]
** long stem:[-2^63~2^63-1]
** boolean
** char `Unicode` stem:[0~2^16-1]
** float `IEEE754`
** double `IEEE754`

* 引用数据类型
** Class
** Interface
** Array

== 注解

. 重复注解使用

   @Repeatable(xxx.class) & getAnnotationsByType(xxx.class);

. Retention

|===
|   | 源码 | 字节码文件 | 运行时获取

| Source
| √
|
|
| Class
| √
| √
|

| Runtime
| √
| √
| √
|===

. Target
* Type: 类、接口、注解、枚举
* Field: 字段
* Method: 方法
* Parameter: 方法参数
* Constructor: 构造函数
* Local_Variable: 局部变量
* Annotation_Type: 只能用在注解上
* Package: 包声明上
* Type_Parameter: 类参数, 尚未参透
* Type_Use: 用在任何声明&定义的类型处

== 枚举

. API
.. values() 返回所有枚举常量
.. valueOf(String) 返回名字对应的枚举常量
.. name() 返回枚举常量名字
.. oridinal() 返回枚举常量的序号
.. compareTo() 比较枚举常量的序号
. EnumMap, EnumSet
.. EnumSet.allOf(Enum.class) 返回包含所有枚举常量的集合
.. EnumSet.rangOf(EnumA,EnumB) 返回A与B之间所有的枚举常量, 包括边界
.. EnumMap#entrySet 为空,forearch用不了, 只能手动put ==to fix==

== 序列化

. 序列化时会调用readObject方法,反序列化时会调用writeObject方法
. serialVersionUID标识类的序列化的版本号,如果反序列化时当前类的版本号与序列化的二进制流对象的版本号不一致则会抛出异常
. 序列化再反序列化后静态成员变量值为最新的

== 接口

. default方法继承判定
* Class优先
* 子接口优先
* 无法确定需用 类名.super 显示调用
. Class#getDeclaredMethods不计算继承的方法

== 泛型

. 上界通配符只能get
. 下界通配符get出Object,add时不能add声明的泛型边界的父类
. 取不到一个类定义的泛型类型(T),只能取其子类或父类具体的泛型类型(Long,String...)

== 反射

. getMethod获取所有public方法(包括父类),getDeclaredMethod获取所有方法(不包括父类)

== 线程

. 线程状态
* NEW
* RUNNABLE
* BLOCKED
* WAITING
* TIMED_WAITING
* TERMINATED
. 线程内异常无法在外层try-catch,只能设置Thread的UncaughtExceptionHandler
. 每一条线程都有自己的栈空间,拥有一份方法参数、局部变量和返回值的拷贝.每一个线程都有自己的一份标识信息,包括线程名、线程优先级、线程是否存活、线程执行状态、守护线程标识等.
. wait()释放对象锁,sleep()不释放.
. Executor:
* ThreadPoolExecutor
* ForkJoinPool
* ScheduledThreadPoolExecutor
... 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
... 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
... 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
... 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

== ClassLoader

* loadClass 实现双亲委托模型
* findClass 实现类文件读取

== Stream

 一个完整的操作是<数据来源，操作，回调函数>构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线

.中间操作:
. 无状态:
.. unordered
.. filter
.. map
.. mapToInt
.. mapToLong
.. mapToDouble
.. flatMap
.. flatMapToInt
.. flatMapToLong
.. flatMapToDouble
.. peek
. 有状态
.. distinct
.. sorted
.. limit
.. skip

.结束操作
. 非短路操作
.. forEach
.. forEachOrdered
.. toArray
.. reduce
.. collect
.. max
.. min
.. count
. 短路操作
.. anyMatch
.. allMatch
.. noneMatch
.. findFirst
.. findAny

== JDBC

=== Statement

* 同一个connection可以创建多个 `Statement`.
* 在处理 `ResultSet` 的结果时也可以创建另外一个 `Statement`.
* `Statement` 不是线程安全的.
* 用完后需要close.
* SQL语句中如果需要使用包含 `?` 符号的函数可以使用 `??` 转义.

=== ResultSet

* 在获取结果集前需要调用 `next()` 方法.
* 使用 `Statement` 获取 `ResultSet` 后, 当前使用中的 `ResultSet` 会直接关闭.
* 用完后需要close.

== NIO

=== Buffer

Buffer是一个存放基本类型(除了boolean)数据的容器, 拥有以下属性/方法:

* capacity:
容器长度
* limit:
能够写入的长度
* position:
下一个被写入的位置
* flip(): 将position赋值给limit, 再将position设置为0, 重置mark
* rewind(): 将position设置为0, 重置mark
* mark(): 将position赋值给mark
* reset(): 将mark赋值给position

== 多处理器编程

=== 定义

线程A产生一个事件序列 stem:[a_0,a_1,...].
由于线程中往往包含循环, 因此一条程序语句可以产生多次事件.
用 stem:[a_i^j] 表示事件 stem:[a_i] 的第 stem:[j] 次发生. 如果事件a在事件b之前发生, 则称a先于b, 记作 stem:[a->b] .

令 stem:[a_0,a_1]表示事件, 且 stem:[a_0->a_1], stem:[I_A] =interval( stem:[a_0->a_1] )表示 stem:[a_0和a_1] 事件之间的间隔.
如果 stem:[a_1->b_0],则 stem:[I_A->I_B].多个不存在 stem:[->]的关系称为 *并发的*.

* *互斥*: 对于线程A,B, 以及整数j,k, 都有 stem:[CS_A^j->CS_B^i]或者stem:[CS_B^j->CS_A^i].
* *无死锁*: 如果一个线程正在尝试获得一个锁, 那么总会成功地获取到锁.
如果暂时无法获得, 那么一定存在其他线程已经进入临界区.
* *无饥饿*: 每个尝试获得锁的线程最终都能成功.
(无饥饿意味着无死锁)

=== 互斥

[source,java]
.Lock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/Lock.java[]
----

==== 双线程实现互斥

[source,java]
.LockOne.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/LockOne.java[]
----

[source,java]
.LockTwo.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/LockTwo.java[]
----

[source,java]
.PetersonLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/PetersonLock.java[]
----

==== 多线程实现互斥

[source,java]
.FilterLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/FilterLock.java[]
----

[source,java]
.BakeryLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/BakeryLock.java[]
----

=== 内存访问

处理器和存储控制器之间通过总线通信, 同一时间只能有一个处理器在总线上广播, 但处理器可以和存储控制器同时广播.
所有的处理器都可以监听.
每一个处理器都有一个cache. 当处理器想从存储器读数据时, 首先检查该内存地址以及值是否已经在cache中. 如果在cache中, 那么处理器可以产生一个cache命中, 立即加载这个值.
如果不在, 则产生一个 `cache miss` , 紧接着在总线上广播这个地址, 其他的处理器监听总线, 如果某个处理器在自己的cache中发现这个地址, 则广播该地址及其值做出响应.
如果所有的处理器都没有发现该地址, 则从内存中加载.

=== 自旋锁

多线程竞争临界区, 如果不能获得锁, 有两种选择:

* 让其继续尝试, 称为 *自旋锁* .
* 挂起自己, 请求操作系统调度另外一个线程, 称为 *阻塞* .

许多操作系统将这两种结合起来使用, 先旋转一个小的时间段再阻塞.

==== TestAndSet

[source,java]
.TASLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/TASLock.java[]
----

.TAS缺点:
* 每个 `getAndSet` 对应总线上一次广播, 该广播会延迟所有的线程, 包括那些没有阻塞锁和准备释放锁的线程.
* `getAndSet` 设置值后会导致所有处理器丢弃 `cache` .

==== TestAndTestAndSet

[source,java]
.TTASLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/TTASLock.java[]
----

.TTAS改进:
* 自旋时只会读取本地的cache值, 不产生总线流量.

==== Backoff TestAndTestAndSet

[source,java]
.Backoff.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/Backoff.java[]
----

[source,java]
.TTASBackoffLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/TTASBackoffLock.java[]
----

.TTASBackoffLock改进:
* 当有其他线程释放锁, 但当前线程没有竞争到锁后会后退一个随机的时间间隔再去争用锁, 减少CPU消耗.

==== 队列锁(数组)

[source,java]
.ArrayLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/ArrayLock.java[]
----

==== 队列锁(CLH)

[source,java]
.CLHLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/CLHLock.java[]
----

==== 队列锁(MCS)

[source,java]
.MCSLock.java
----
include::../basic-knowledge/src/test/java/me/jy/lock/spin/MCSLock.java[]
----

== QA

[qanda]
`|` 和 `||` 的区别?::
`||` 是短路操作, 如果左边是true, 则右边不会执行. `|` 左右两边都会执行.
Java异常分类?::
* Checked Exception:
继承Exception但不是RuntimeException的异常类.
需要程序手动处理.
* Unchecked Exception:
继承RuntimeException/Error的异常类.
程序可以选择捕获处理, 也可以不处理.
//Java异常处理流程?::
`ClassLoader.loadClass()` 和 `Class.forName()` 有什么区别?::
`Class.forName()` 会初始化类的static代码块和static参数, `ClassLoader.loadClass()` 不会.
`ClassNotFoundException` 和 `NoClassDefFoundError` 有什么区别?::
* `ClassNotFoundException` 是Exception类型, `NoClassDefFoundError` 是Error类型.
* 使用 `Class.forName()` / `ClassLoader.loadClass()` / `ClassLoader.findSystemClass()` 动态加载类时找不到类就会抛出 `ClassNotFoundException` ,当编译成功但运行时(调用该类的一个方法或者new一个实例时)找不到类或者初始化static成员时有异常则会抛出 `NoClassDefFoundError` 异常.
强引用/软引用/弱引用/虚引用区别及使用场景?::
* 普通对象被其他对象引用, 这样的引用为强引用.
* JVM在内存不足时回收软引用
* TODO

