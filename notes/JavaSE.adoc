= Java
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: idea
:sectlinks:
:sectnums:
:stem:
:toc: left
:toclevels: 3
:toc-title: 目录
:tabsize: 4
:docinfo: shared

== 注解
. 重复注解使用

   @Repeatable(xxx.class) & getAnnotationsByType(xxx.class);

. Retention

|===
|   | 源码 | 字节码文件 | 运行时获取

| Source
| √
|
|
| Class
| √
| √
|

| Runtime
| √
| √
| √
|===

. Target

   * Type: 类、接口、注解、枚举
   * Field: 字段
   * Method: 方法
   * Parameter: 方法参数
   * Constructor: 构造函数
   * Local_Variable: 局部变量
   * Annotation_Type: 只能用在注解上
   * Package: 包声明上
   * Type_Parameter: 类参数, 尚未参透
   * Type_Use: 用在任何声明&定义的类型处

== 枚举

. API
   .. values() 返回所有枚举常量
   .. valueOf(String) 返回名字对应的枚举常量
   .. name() 返回枚举常量名字
   .. oridinal() 返回枚举常量的序号
   .. compareTo() 比较枚举常量的序号
. EnumMap, EnumSet
   .. EnumSet.allOf(Enum.class) 返回包含所有枚举常量的集合
   .. EnumSet.rangOf(EnumA,EnumB) 返回A与B之间所有的枚举常量, 包括边界
   .. EnumMap#entrySet 为空,forearch用不了, 只能手动put   ==to fix==

== 序列化

. 序列化时会调用readObject方法,反序列化时会调用writeObject方法
. serialVersionUID标识类的序列化的版本号,如果反序列化时当前类的版本号与序列化的二进制流对象的版本号不一致则会抛出异常
. 序列化再反序列化后静态成员变量值为最新的


== 接口

. default方法继承判定
   * Class优先
   * 子接口优先
   * 无法确定需用 类名.super 显示调用
. Class#getDeclaredMethods不计算继承的方法

== 泛型

. 上界通配符只能get
. 下界通配符get出Object,add时不能add声明的泛型边界的父类
. 取不到一个类定义的泛型类型(T),只能取其子类或父类具体的泛型类型(Long,String...)

== 反射
.  getMethod获取所有public方法(包括父类),getDeclaredMethod获取所有方法(不包括父类)

== 线程

. 线程状态
   * NEW
   * RUNNABLE
   * BLOCKED
   * WAITING
   * TIMED_WAITING
   * TERMINATED
. 线程内异常无法在外层try-catch,只能设置Thread的UncaughtExceptionHandler
. 每一条线程都有自己的栈空间,拥有一份方法参数、局部变量和返回值的拷贝.每一个线程都有自己的一份标识信息,包括线程名、线程优先级、线程是否存活、线程执行状态、守护线程标识等.
. wait()释放对象锁,sleep()不释放.
. Executor:
   * ThreadPoolExecutor
   * ForkJoinPool
   * ScheduledThreadPoolExecutor
   ... 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
   ... 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
   ... 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
   ... 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

== ClassLoader

* loadClass 实现双亲委托模型
* findClass 实现类文件读取

== Stream

 一个完整的操作是<数据来源，操作，回调函数>构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线

.中间操作:
. 无状态:
.. unordered
.. filter
.. map
.. mapToInt
.. mapToLong
.. mapToDouble
.. flatMap
.. flatMapToInt
.. flatMapToLong
.. flatMapToDouble
.. peek
. 有状态
.. distinct
.. sorted
.. limit
.. skip

.结束操作
. 非短路操作
.. forEach
.. forEachOrdered
.. toArray
.. reduce
.. collect
.. max
.. min
.. count
. 短路操作
.. anyMatch
.. allMatch
.. noneMatch
.. findFirst
.. findAny

== JDBC

=== Statement

* 同一个connection可以创建多个 `Statement`.
* 在处理 `ResultSet` 的结果时也可以创建另外一个 `Statement`.
* `Statement` 不是线程安全的.
* 用完后需要close.
* SQL语句中如果需要使用包含 `?` 符号的函数可以使用 `??` 转义.

=== ResultSet

* 在获取结果集前需要调用 `next()` 方法.
* 使用 `Statement` 获取 `ResultSet` 后, 当前使用中的 `ResultSet` 会直接关闭.
* 用完后需要close.

== NIO

=== Buffer

Buffer是一个存放基本类型(除了boolean)数据的容器, 拥有以下属性/方法:

* capacity:
容器长度
* limit:
能够写入的长度
* position:
下一个被写入的位置
* flip(): 将position赋值给limit, 再将position设置为0, 重置mark
* rewind(): 将position设置为0, 重置mark
* mark(): 将position赋值给mark
* reset(): 将mark赋值给position

== QA

[qanda]
`ClassLoader.loadClass()` 和 `Class.forName()` 有什么区别?::
`Class.forName()` 会初始化类的static代码块和static参数, `ClassLoader.loadClass()` 不会.
`ClassNotFoundException` 和 `NoClassDefFoundError` 有什么区别?::
* `ClassNotFoundException` 是Exception类型, `NoClassDefFoundError` 是Error类型.
* 使用 `Class.forName()` / `ClassLoader.loadClass()` / `ClassLoader.findSystemClass()` 动态加载类时找不到类就会抛出 `ClassNotFoundException` ,当编译成功但运行时(调用该类的一个方法或者new一个实例时)找不到类或者初始化static成员时有异常则会抛出 `NoClassDefFoundError` 异常.
Java异常分类?::
* Checked Exception:
继承Exception但不是RuntimeException的异常类.
* Unchecked Exception:
继承RuntimeException/Error的异常类.
强引用/软引用/弱引用/虚引用区别及使用场景?::
* 普通对象被其他对象引用, 这样的引用为强引用.
* JVM在内存不足时回收软引用
* TODO

